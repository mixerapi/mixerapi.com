{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MixerAPI Streamline development of API-first applications in CakePHP. MixerAPI makes building RESTful APIs a piece of cake. Features MixerAPI scaffolds your API in seconds with a custom Bake template, automatically generates OpenAPI into Swagger or Redoc from your existing code (annotations not required), handles exception rendering in XML or JSON for CRUD operations, and comes with HAL+JSON and JSON-LD. Demo Checkout the live demo or browse the demo source code. Quick Start Get started in seconds using composer or docker. Docker @todo Composer composer require mixerapi/mixerapi To load all MixerApi plugins run bin/cake plugin load MixerApi . Alternatively, you can modify your Applications bootstrap method yourself: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi' ); }","title":"MixerAPI"},{"location":"#mixerapi","text":"Streamline development of API-first applications in CakePHP. MixerAPI makes building RESTful APIs a piece of cake.","title":"MixerAPI"},{"location":"#features","text":"MixerAPI scaffolds your API in seconds with a custom Bake template, automatically generates OpenAPI into Swagger or Redoc from your existing code (annotations not required), handles exception rendering in XML or JSON for CRUD operations, and comes with HAL+JSON and JSON-LD.","title":"Features"},{"location":"#demo","text":"Checkout the live demo or browse the demo source code.","title":"Demo"},{"location":"#quick-start","text":"Get started in seconds using composer or docker.","title":"Quick Start"},{"location":"#docker","text":"@todo","title":"Docker"},{"location":"#composer","text":"composer require mixerapi/mixerapi To load all MixerApi plugins run bin/cake plugin load MixerApi . Alternatively, you can modify your Applications bootstrap method yourself: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi' ); }","title":"Composer"},{"location":"bake/","text":"MixerAPI Bake Bake RESTful CakePHP controllers in seconds with this API focused bake template. Installation composer require mixerapi/bake bin/cake plugin load MixerApi/Bake Alternatively after composer installing you can manually load the plugin in your Application: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/Bake' ); } Usage Add --theme MixerApi/Bake to your bake commands. Examples: # bake all your controllers bin/cake bake controller all --theme MixerApi/Bake # bake a single controller bin/cake bake controller { ControllerName } --theme MixerApi/Bake # you can even bake the entire application still, MixerApi/Bake only deals with controller files bin/cake bake all --everything --theme MixerApi/Bake Click here to see a sample controller. Unit Tests vendor/bin/phpunit Code Standards composer check","title":"MixerAPI Bake"},{"location":"bake/#mixerapi-bake","text":"Bake RESTful CakePHP controllers in seconds with this API focused bake template.","title":"MixerAPI Bake"},{"location":"bake/#installation","text":"composer require mixerapi/bake bin/cake plugin load MixerApi/Bake Alternatively after composer installing you can manually load the plugin in your Application: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/Bake' ); }","title":"Installation"},{"location":"bake/#usage","text":"Add --theme MixerApi/Bake to your bake commands. Examples: # bake all your controllers bin/cake bake controller all --theme MixerApi/Bake # bake a single controller bin/cake bake controller { ControllerName } --theme MixerApi/Bake # you can even bake the entire application still, MixerApi/Bake only deals with controller files bin/cake bake all --everything --theme MixerApi/Bake Click here to see a sample controller.","title":"Usage"},{"location":"bake/#unit-tests","text":"vendor/bin/phpunit","title":"Unit Tests"},{"location":"bake/#code-standards","text":"composer check","title":"Code Standards"},{"location":"cakephp-swagger-bake/","text":"SwaggerBake plugin for CakePHP4 A delightfully tasty tool for generating Swagger documentation with OpenApi 3.0.0 schema. This plugin automatically builds your Swagger UI and ReDoc from your existing cake models and routes. Creates OpenApi paths and operations from your RESTful routes and controllers. Creates OpenAPI Schema from your Entities and Tables. Integrates with: Paginator , friendsofcake/search , Authentication , Validator , and Bake . Provides additional functionality through Annotations and Doc Blocks. Demo Site | Demo Code | Screenshot Table of Contents Installation Setup Getting Started Automatic Documentation Doc Blocks Annotations for Extended Functionality Extending SwaggerBake Debug Commands Bake Theme ... Installation SwaggerBake requires CakePHP4 and a few dependencies that will be automatically installed via composer. composer require cnizzardini/cakephp-swagger-bake Run bin/cake plugin load SwaggerBake or manually load the plugin: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'SwaggerBake' ); } Setup For standard applications that have not split their API into plugins, the automated setup should work. Otherwise use the manual setup. Automated Setup Run bin/cake swagger install and then add a route . Manual Setup Create a base swagger.yml file in config\\swagger.yml . An example file is provided here . Create a config/swagger_bake.php file. See the example file here for further explanation. Then just add a route. Add a route to SwaggerUI Create a route for the SwaggerUI page in config/routes.php , example: $builder -> connect ( '/my-swagger-ui' , [ 'controller' => 'Swagger' , 'action' => 'index' , 'plugin' => 'SwaggerBake' ]); Getting Started You can generate OpenAPI json from the command line at anytime with bin/cake swagger bake . If Hot Reload is enabled ( see config ) OpenAPI will be generated each time you browse to SwaggerUI (or Redoc) in your web browser. Checkout the debug commands for troubleshooting and the bake theme for generating RESTful controllers. Automatic Documentation I built this library to reduce the need for annotations to build documentation. SwaggerBake will automatically build the following from your existing routes and models without additional effort: Paths Resource (route) Operations Summary and description GET, POST, PATCH, DELETE Form fields and JSON using your Cake models Responses Sub resources Security/Authentication Schema See details for how CakePHP conventions are interpreted into OpenAPI 3.0 schema. SwaggerBake works with your existing YML definitions and will not overwrite anything. By default, it uses components > schemas > Exception as your Swagger documentations Exception schema. See the default swagger.yml and exceptionSchema in swagger_bake.php for more info. Doc Blocks SwaggerBake will parse your DocBlocks for information. The first line reads as the Operation Summary and the second as the Operation Description, @see , @deprecated , and @throws are also supported. Throw tags use the Exception classes HTTP status code. For instance, a MethodNotAllowedException displays as a 405 response in Swagger UI, while a standard PHP Exception displays as a 500 code. /** * Swagger Operation Summary * * This displays as the operations long description * * @see https://book.cakephp.org/4/en/index.html The link and this description appear in Swagger * @deprecated * @throws BadRequestException An optional bad request description here * @throws Exception */ public function index () {} Annotations for Extended Functionality SwaggerBake provides some optional Annotations for enhanced functionality. These can be imported individually from SwaggerBake\\Lib\\Annotation or set to an alias such as Swag : use SwaggerBake\\Lib\\Annotation as Swag . Read the Annotations README for detailed examples. @SwagPaginator Method level annotation for adding CakePHP Paginator query parameters: page, limit, sort, and direction. Read more /** * @Swag\\SwagPaginator */ public function index () {} @SwagSearch Method level annotation for documenting search parameters using the popular friendsofcake/search plugin. Read more use SwaggerBake\\Lib\\Extension\\CakeSearch\\Annotation\\SwagSearch ; /** * @SwagSearch(tableClass=\"\\App\\Model\\Table\\ActorsTable\", collection=\"default\") */ public function index () {} @SwagQuery Method level annotation for adding query parameters. Read more /** * @Swag\\SwagQuery(name=\"queryParamName\", type=\"string\", description=\"string\") */ public function index () {} @SwagForm Method level annotation for adding form data fields. Read more /** * @Swag\\SwagForm(name=\"fieldName\", type=\"string\", description=\"string\", required=false, enum={\"a\",\"b\"}) */ public function index () {} @SwagDto Method level annotation for building query or form parameters from a DataTransferObject. DTOs are more than just a best practice. Using them with SwaggerBake greatly reduces the amount of annotations you need to write. Consider using a DTO in place of SwagQuery or SwagForm. Read more @SwagDtoQuery Property level annotation for use in your SwagDto classes. Read more @SwagDtoForm Property level annotation for use in your SwagDto classes. Read more @SwagHeader Method level annotation for adding header parameters. Read more /** * @Swag\\SwagHeader(name=\"X-HEAD-ATTRIBUTE\", type=\"string\", description=\"string\") */ public function index () {} @SwagPathParameter Method level annotation for modifying path parameters. Read more /** * @Swag\\SwagPathParameter(name=\"id\", type=\"integer\", format=\"int64\", description=\"ID\") */ public function view ( $id ) {} @SwagSecurity Method level annotation for adding authentication requirements. This annotation takes precedence over settings that SwaggerBake gathers from AuthenticationComponent. Read details below /** * @Swag\\SwagSecurity(name=\"BearerAuth\", scopes={\"Read\",\"Write\"}) */ public function index () {} @SwagOperation Method level annotation for OpenApi Operations. Read more /** * @Swag\\SwagOperation(isVisible=false, tagNames={\"MyTag\",\"AnotherTag\"}, showPut=false) */ public function index () {} @SwagRequestBody Method level annotation for describing request body. Set ignoreCakeSchema for full control over request body. Read more /** * @Swag\\SwagRequestBody(description=\"my description\", required=true, ignoreCakeSchema=true) */ public function index () {} @SwagRequestBodyContent Method level annotation for describing custom content in request body. The mimeTypes parameter is optional. If empty, all mimeTypes defined as requestAccepts in your swagger_bake.php will be used. Read more mimeType has been deprecated in >= v1.5, use array form with mimeTypes /** * @Swag\\SwagRequestBodyContent(refEntity=\"#/components/schemas/Actor\", mimeTypes={\"application/json\"}) */ public function index () {} @SwagResponseSchema Method level annotation for defining response schema. Read more mimeType is deprecated in >= v1.5, use mimeTypes as an array. httpCode is deprecated in >= v1.3, use statusCode /** * @Swag\\SwagResponseSchema(refEntity=\"#/components/schemas/Actor\", description=\"Summary\", statusCode=\"200\") */ public function index () {} @SwagPath Class level annotation for exposing controllers to Swagger UI. You can hide entire controllers with this annotation. Read more /** * @Swag\\SwagPath(isVisible=false, description=\"optional description\", summary=\"operational summary\") */ class UsersController extends AppController { @SwagEntity Class level annotation for exposing entities to Swagger UI. By default, all entities with routes will display as Swagger schema. You can hide a schema or display a schema that does not have an associated route. Read more /** * @Swag\\SwagEntity(isVisible=false, title=\"optional title\", description=\"optional description\") */ class Employee extends Entity { @SwagEntityAttribute Class level annotation for customizing Schema Attributes. Read more /** * @Swag\\SwagEntityAttribute(name=\"modified\", type=\"string\", description=\"string\") */ class Employee extends Entity { Extending SwaggerBake There are several options to extend functionality. Using Your Own SwaggerUI You may use your own swagger install in lieu of the version that comes with SwaggerBake. Simply don't add a custom route as indicated in the installation steps. In this case just reference the generated swagger.json within your userland Swagger UI install. Using Your Own Controller You might want to perform some additional logic (checking for authentication) before rendering the built-in Swagger UI. This is easy to do. Just create your own route and controller, then reference the built-in layout and template: // config/routes.php $builder -> connect ( '/my-swagger-docs' , [ 'controller' => 'MySwagger' , 'action' => 'index' ]); To get started, copy SwaggerController into your project. Using Your Own Layout and Templates You will need to use your own controller (see above). From there you can copy the layouts and templates into your project and inform your controller action to use them instead. Checkout out the CakePHP documentation on Views for specifics. This can be useful if you'd like to add additional functionality to SwaggerUI (or Redoc) using their APIs or if your project is not installed in your web servers document root (i.e. a sub-folder). Generate Swagger On Your Terms There a three options for generating swagger.json: Call swagger bake which can be included as part of your build process. Enable the hotReload option in config/swagger_bake.php (recommended for local development only). Call SwaggerBake programmatically: $swagger = ( new \\SwaggerBake\\Lib\\Factory\\SwaggerFactory ()) -> create (); $swagger -> getArray (); # returns swagger array $swagger -> toString (); # returns swagger json $swagger -> writeFile ( '/full/path/to/your/swagger.json' ); # writes swagger.json Multiple Instances of Swagger Bake If your application has multiple APIs that are split into plugins you can generate unique OpenAPI schema, Swagger UI, and Redoc for each plugin. Setup a new swagger_bake.php and swagger.yaml in plugins/OtherApi/config . These configurations should point to your plugins paths and namespaces. Next, create a custom SwaggerController and load the configuration within initialize() : public function initialize () : void { parent :: initialize (); // TODO: Change the autogenerated stub Configure :: load ( 'OtherApi.swagger_bake' , 'default' ); $this -> loadComponent ( 'SwaggerBake.SwaggerUi' ); } When running bin/cake swagger bake you will need to specify your plugins swagger_bake config: bin/cake swagger bake --config OtherApi.swagger_bake Event System You can extend Swagger Bake further with events. Read the extension documentation for details. Debug Commands In addition to swagger bake these console helpers provide insight into how your Swagger documentation is generated. swagger routes Displays a list of routes that can be viewed in Swagger. bin/cake swagger routes swagger models Displays a list of models that can be viewed in Swagger. bin/cake swagger models Bake Theme SwaggerBake comes with Bake templates for scaffolding RESTful controllers compatible with SwaggerBake and OpenAPI 3.0 schema. Using the bake theme is completely optional, but will save you some time since the default bake theme is not specifically designed for RESTful APIs. bin/cake bake controller {Name} --theme SwaggerBake Details OpenAPI Schema Support Roadmap Swagger uses your existing swagger.yml as a base for adding additional paths and schema. Generates JSON based on the OpenAPI 3 specification. I am still working on implementing the full spec. All Schemas and Paths generated must have the following in your CakePHP Application: App\\Model\\Entity class (for schemas only) App\\Controller class Must be a valid route Three versions of schema will be created: Default with all properties #/components/schemas/Entity Writeable properties #/x-swagger-bake/components/schemas/Entity-Write Readable properties #/x-swagger-bake/components/schemas/Entity-Read Entity Attributes: Hidden attributes will not be visible Primary Keys will be set to read only by default. DateTime fields named created and modified are automatically set to read only per Cake convention. CRUD Responses Index, Edit, Add, and View methods default to an HTTP 200 with the Controllers related Cake Entity schema. Delete defaults to HTTP 204 (no content). Table Validators: Reads in Validator rules such as requirePresence, minLength, maxLength, basic math comparison operators, regex, inList, hasAtLeast, and hasAtMost. Security Scheme Leverages the CakePHP AuthenticationComponent Will automatically set security on operations if a single securityScheme is defined in your swagger.yaml. If more than one security schema exists you will need to use @SwagSecurity . @SwagSecurity takes precedence. SwaggerBake supports the following formats: application/json, application/x-www-form-urlencoded, application/xml, application/hal+json, and application/ld+json SwaggerBake does not document schema associations. If your application includes associations on things like GET requests, you can easily add them into your swagger documentation through the OpenAPI allOf property. Since SwaggerBake works in conjunction with OpenAPI YAML you can easily add a new schema with this association. Below is an example of extending an existing City schema to include a Country association. # in your swagger.yml components : schemas : CityExtended : description : 'City with extended information including Country' type : object allOf : - $ref : '#/components/schemas/City' - type : object properties : country : $ref : '#/components/schemas/Country' Then in your controller action you'd specify the Schema: /** * View method * @Swag\\SwagResponseSchema(refEntity=\"#/components/schemas/CityExtended\") */ public function view ( $id ) { $this -> request -> allowMethod ( 'get' ); $city = $this -> Cities -> get ( $id , [ 'contain' => [ 'Countries' ]]); $this -> set ( compact ( 'cities' )); $this -> viewBuilder () -> setOption ( 'serialize' , 'cities' ); } The demo application includes this and many other examples of usage. Read more about oneOf , anyOf , allOf , and not in the OpenAPI 3 documentation . Supported Versions This is built for CakePHP 4.x only. A cake-3.8 option is available, but not supported. Version Cake Version Supported Unit Tests Notes 1.* 4.* Yes Yes Currently supported cake-3.8 3.8.* No Yes See branch cake-3.8. Completely untested and unsupported Common Issues Swagger UI No API definition provided. Verify that swagger.json exists. SwaggerBakeRunTimeExceptions Unable to create swagger file. Try creating an empty file first or checking permissions Create the swagger.json manually matching the path in your config/swagger_bake.php file. Output file is not writable Change permissions on your swagger.json file , 764 should do. Controller not found Make sure a controller actually exists for the route resource. Other Issues Missing actions (missing paths) in Swagger By default Cake RESTful resources will only create routes for index, view, add, edit and delete. You can add and remove paths using CakePHPs route resource functionality. Read the Cake Routing documentation which describes in detail how to add, remove, modify, and alter routes. Missing CSRF token body Either disable CSRF protection on your main route in config/routes.php or enable CSRF protection in Swagger UI. The library does not currently support adding this in for you. My route isn't displaying in Swagger UI Make sure the route is properly defined in your config/routes.php file. Reporting Issues This is a new library so please take some steps before reporting issues. You can copy & paste the JSON SwaggerBake outputs into https://editor.swagger.io/ which will automatically convert the JSON into YML and display potential schema issues. Please included the following in your issues a long with a brief description: Steps to Reproduce Actual Outcome Expected Outcome Feature requests are welcomed. Contribute Send pull requests to help improve this library. You can include SwaggerBake in your primary Cake project as a local source to make developing easier: Make a fork of this repository and clone it to your localhost Remove cnizzardini\\cakephp-swagger-bake from your composer.json Add a paths repository to your composer.json \"minimum-stability\": \"dev\", \"repositories\": [ { \"type\": \"path\", \"url\": \"/absolute/local-path-to/cakephp-swagger-bake\", \"options\": { \"symlink\": true } } ] Run composer require cnizzardini/cakephp-swagger-bake @dev Undo these steps when you're done. Read the full composer documentation on loading from path here: https://getcomposer.org/doc/05-repositories.md#path Coding Standards Coding standards run as part of CI with Travis. You may run these locally with composer check . Unit Tests vendor/bin/phpunit","title":"SwaggerBake plugin for CakePHP4"},{"location":"cakephp-swagger-bake/#swaggerbake-plugin-for-cakephp4","text":"A delightfully tasty tool for generating Swagger documentation with OpenApi 3.0.0 schema. This plugin automatically builds your Swagger UI and ReDoc from your existing cake models and routes. Creates OpenApi paths and operations from your RESTful routes and controllers. Creates OpenAPI Schema from your Entities and Tables. Integrates with: Paginator , friendsofcake/search , Authentication , Validator , and Bake . Provides additional functionality through Annotations and Doc Blocks. Demo Site | Demo Code | Screenshot","title":"SwaggerBake plugin for CakePHP4"},{"location":"cakephp-swagger-bake/#table-of-contents","text":"Installation Setup Getting Started Automatic Documentation Doc Blocks Annotations for Extended Functionality Extending SwaggerBake Debug Commands Bake Theme ...","title":"Table of Contents"},{"location":"cakephp-swagger-bake/#installation","text":"SwaggerBake requires CakePHP4 and a few dependencies that will be automatically installed via composer. composer require cnizzardini/cakephp-swagger-bake Run bin/cake plugin load SwaggerBake or manually load the plugin: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'SwaggerBake' ); }","title":"Installation"},{"location":"cakephp-swagger-bake/#setup","text":"For standard applications that have not split their API into plugins, the automated setup should work. Otherwise use the manual setup.","title":"Setup"},{"location":"cakephp-swagger-bake/#automated-setup","text":"Run bin/cake swagger install and then add a route .","title":"Automated Setup"},{"location":"cakephp-swagger-bake/#manual-setup","text":"Create a base swagger.yml file in config\\swagger.yml . An example file is provided here . Create a config/swagger_bake.php file. See the example file here for further explanation. Then just add a route.","title":"Manual Setup"},{"location":"cakephp-swagger-bake/#add-a-route-to-swaggerui","text":"Create a route for the SwaggerUI page in config/routes.php , example: $builder -> connect ( '/my-swagger-ui' , [ 'controller' => 'Swagger' , 'action' => 'index' , 'plugin' => 'SwaggerBake' ]);","title":"Add a route to SwaggerUI"},{"location":"cakephp-swagger-bake/#getting-started","text":"You can generate OpenAPI json from the command line at anytime with bin/cake swagger bake . If Hot Reload is enabled ( see config ) OpenAPI will be generated each time you browse to SwaggerUI (or Redoc) in your web browser. Checkout the debug commands for troubleshooting and the bake theme for generating RESTful controllers.","title":"Getting Started"},{"location":"cakephp-swagger-bake/#automatic-documentation","text":"I built this library to reduce the need for annotations to build documentation. SwaggerBake will automatically build the following from your existing routes and models without additional effort: Paths Resource (route) Operations Summary and description GET, POST, PATCH, DELETE Form fields and JSON using your Cake models Responses Sub resources Security/Authentication Schema See details for how CakePHP conventions are interpreted into OpenAPI 3.0 schema. SwaggerBake works with your existing YML definitions and will not overwrite anything. By default, it uses components > schemas > Exception as your Swagger documentations Exception schema. See the default swagger.yml and exceptionSchema in swagger_bake.php for more info.","title":"Automatic Documentation"},{"location":"cakephp-swagger-bake/#doc-blocks","text":"SwaggerBake will parse your DocBlocks for information. The first line reads as the Operation Summary and the second as the Operation Description, @see , @deprecated , and @throws are also supported. Throw tags use the Exception classes HTTP status code. For instance, a MethodNotAllowedException displays as a 405 response in Swagger UI, while a standard PHP Exception displays as a 500 code. /** * Swagger Operation Summary * * This displays as the operations long description * * @see https://book.cakephp.org/4/en/index.html The link and this description appear in Swagger * @deprecated * @throws BadRequestException An optional bad request description here * @throws Exception */ public function index () {}","title":"Doc Blocks"},{"location":"cakephp-swagger-bake/#annotations-for-extended-functionality","text":"SwaggerBake provides some optional Annotations for enhanced functionality. These can be imported individually from SwaggerBake\\Lib\\Annotation or set to an alias such as Swag : use SwaggerBake\\Lib\\Annotation as Swag . Read the Annotations README for detailed examples.","title":"Annotations for Extended Functionality"},{"location":"cakephp-swagger-bake/#swagpaginator","text":"Method level annotation for adding CakePHP Paginator query parameters: page, limit, sort, and direction. Read more /** * @Swag\\SwagPaginator */ public function index () {}","title":"@SwagPaginator"},{"location":"cakephp-swagger-bake/#swagsearch","text":"Method level annotation for documenting search parameters using the popular friendsofcake/search plugin. Read more use SwaggerBake\\Lib\\Extension\\CakeSearch\\Annotation\\SwagSearch ; /** * @SwagSearch(tableClass=\"\\App\\Model\\Table\\ActorsTable\", collection=\"default\") */ public function index () {}","title":"@SwagSearch"},{"location":"cakephp-swagger-bake/#swagquery","text":"Method level annotation for adding query parameters. Read more /** * @Swag\\SwagQuery(name=\"queryParamName\", type=\"string\", description=\"string\") */ public function index () {}","title":"@SwagQuery"},{"location":"cakephp-swagger-bake/#swagform","text":"Method level annotation for adding form data fields. Read more /** * @Swag\\SwagForm(name=\"fieldName\", type=\"string\", description=\"string\", required=false, enum={\"a\",\"b\"}) */ public function index () {}","title":"@SwagForm"},{"location":"cakephp-swagger-bake/#swagdto","text":"Method level annotation for building query or form parameters from a DataTransferObject. DTOs are more than just a best practice. Using them with SwaggerBake greatly reduces the amount of annotations you need to write. Consider using a DTO in place of SwagQuery or SwagForm. Read more","title":"@SwagDto"},{"location":"cakephp-swagger-bake/#swagdtoquery","text":"Property level annotation for use in your SwagDto classes. Read more","title":"@SwagDtoQuery"},{"location":"cakephp-swagger-bake/#swagdtoform","text":"Property level annotation for use in your SwagDto classes. Read more","title":"@SwagDtoForm"},{"location":"cakephp-swagger-bake/#swagheader","text":"Method level annotation for adding header parameters. Read more /** * @Swag\\SwagHeader(name=\"X-HEAD-ATTRIBUTE\", type=\"string\", description=\"string\") */ public function index () {}","title":"@SwagHeader"},{"location":"cakephp-swagger-bake/#swagpathparameter","text":"Method level annotation for modifying path parameters. Read more /** * @Swag\\SwagPathParameter(name=\"id\", type=\"integer\", format=\"int64\", description=\"ID\") */ public function view ( $id ) {}","title":"@SwagPathParameter"},{"location":"cakephp-swagger-bake/#swagsecurity","text":"Method level annotation for adding authentication requirements. This annotation takes precedence over settings that SwaggerBake gathers from AuthenticationComponent. Read details below /** * @Swag\\SwagSecurity(name=\"BearerAuth\", scopes={\"Read\",\"Write\"}) */ public function index () {}","title":"@SwagSecurity"},{"location":"cakephp-swagger-bake/#swagoperation","text":"Method level annotation for OpenApi Operations. Read more /** * @Swag\\SwagOperation(isVisible=false, tagNames={\"MyTag\",\"AnotherTag\"}, showPut=false) */ public function index () {}","title":"@SwagOperation"},{"location":"cakephp-swagger-bake/#swagrequestbody","text":"Method level annotation for describing request body. Set ignoreCakeSchema for full control over request body. Read more /** * @Swag\\SwagRequestBody(description=\"my description\", required=true, ignoreCakeSchema=true) */ public function index () {}","title":"@SwagRequestBody"},{"location":"cakephp-swagger-bake/#swagrequestbodycontent","text":"Method level annotation for describing custom content in request body. The mimeTypes parameter is optional. If empty, all mimeTypes defined as requestAccepts in your swagger_bake.php will be used. Read more mimeType has been deprecated in >= v1.5, use array form with mimeTypes /** * @Swag\\SwagRequestBodyContent(refEntity=\"#/components/schemas/Actor\", mimeTypes={\"application/json\"}) */ public function index () {}","title":"@SwagRequestBodyContent"},{"location":"cakephp-swagger-bake/#swagresponseschema","text":"Method level annotation for defining response schema. Read more mimeType is deprecated in >= v1.5, use mimeTypes as an array. httpCode is deprecated in >= v1.3, use statusCode /** * @Swag\\SwagResponseSchema(refEntity=\"#/components/schemas/Actor\", description=\"Summary\", statusCode=\"200\") */ public function index () {}","title":"@SwagResponseSchema"},{"location":"cakephp-swagger-bake/#swagpath","text":"Class level annotation for exposing controllers to Swagger UI. You can hide entire controllers with this annotation. Read more /** * @Swag\\SwagPath(isVisible=false, description=\"optional description\", summary=\"operational summary\") */ class UsersController extends AppController {","title":"@SwagPath"},{"location":"cakephp-swagger-bake/#swagentity","text":"Class level annotation for exposing entities to Swagger UI. By default, all entities with routes will display as Swagger schema. You can hide a schema or display a schema that does not have an associated route. Read more /** * @Swag\\SwagEntity(isVisible=false, title=\"optional title\", description=\"optional description\") */ class Employee extends Entity {","title":"@SwagEntity"},{"location":"cakephp-swagger-bake/#swagentityattribute","text":"Class level annotation for customizing Schema Attributes. Read more /** * @Swag\\SwagEntityAttribute(name=\"modified\", type=\"string\", description=\"string\") */ class Employee extends Entity {","title":"@SwagEntityAttribute"},{"location":"cakephp-swagger-bake/#extending-swaggerbake","text":"There are several options to extend functionality.","title":"Extending SwaggerBake"},{"location":"cakephp-swagger-bake/#using-your-own-swaggerui","text":"You may use your own swagger install in lieu of the version that comes with SwaggerBake. Simply don't add a custom route as indicated in the installation steps. In this case just reference the generated swagger.json within your userland Swagger UI install.","title":"Using Your Own SwaggerUI"},{"location":"cakephp-swagger-bake/#using-your-own-controller","text":"You might want to perform some additional logic (checking for authentication) before rendering the built-in Swagger UI. This is easy to do. Just create your own route and controller, then reference the built-in layout and template: // config/routes.php $builder -> connect ( '/my-swagger-docs' , [ 'controller' => 'MySwagger' , 'action' => 'index' ]); To get started, copy SwaggerController into your project.","title":"Using Your Own Controller"},{"location":"cakephp-swagger-bake/#using-your-own-layout-and-templates","text":"You will need to use your own controller (see above). From there you can copy the layouts and templates into your project and inform your controller action to use them instead. Checkout out the CakePHP documentation on Views for specifics. This can be useful if you'd like to add additional functionality to SwaggerUI (or Redoc) using their APIs or if your project is not installed in your web servers document root (i.e. a sub-folder).","title":"Using Your Own Layout and Templates"},{"location":"cakephp-swagger-bake/#generate-swagger-on-your-terms","text":"There a three options for generating swagger.json: Call swagger bake which can be included as part of your build process. Enable the hotReload option in config/swagger_bake.php (recommended for local development only). Call SwaggerBake programmatically: $swagger = ( new \\SwaggerBake\\Lib\\Factory\\SwaggerFactory ()) -> create (); $swagger -> getArray (); # returns swagger array $swagger -> toString (); # returns swagger json $swagger -> writeFile ( '/full/path/to/your/swagger.json' ); # writes swagger.json","title":"Generate Swagger On Your Terms"},{"location":"cakephp-swagger-bake/#multiple-instances-of-swagger-bake","text":"If your application has multiple APIs that are split into plugins you can generate unique OpenAPI schema, Swagger UI, and Redoc for each plugin. Setup a new swagger_bake.php and swagger.yaml in plugins/OtherApi/config . These configurations should point to your plugins paths and namespaces. Next, create a custom SwaggerController and load the configuration within initialize() : public function initialize () : void { parent :: initialize (); // TODO: Change the autogenerated stub Configure :: load ( 'OtherApi.swagger_bake' , 'default' ); $this -> loadComponent ( 'SwaggerBake.SwaggerUi' ); } When running bin/cake swagger bake you will need to specify your plugins swagger_bake config: bin/cake swagger bake --config OtherApi.swagger_bake","title":"Multiple Instances of Swagger Bake"},{"location":"cakephp-swagger-bake/#event-system","text":"You can extend Swagger Bake further with events. Read the extension documentation for details.","title":"Event System"},{"location":"cakephp-swagger-bake/#debug-commands","text":"In addition to swagger bake these console helpers provide insight into how your Swagger documentation is generated.","title":"Debug Commands"},{"location":"cakephp-swagger-bake/#swagger-routes","text":"Displays a list of routes that can be viewed in Swagger. bin/cake swagger routes","title":"swagger routes"},{"location":"cakephp-swagger-bake/#swagger-models","text":"Displays a list of models that can be viewed in Swagger. bin/cake swagger models","title":"swagger models"},{"location":"cakephp-swagger-bake/#bake-theme","text":"SwaggerBake comes with Bake templates for scaffolding RESTful controllers compatible with SwaggerBake and OpenAPI 3.0 schema. Using the bake theme is completely optional, but will save you some time since the default bake theme is not specifically designed for RESTful APIs. bin/cake bake controller {Name} --theme SwaggerBake","title":"Bake Theme"},{"location":"cakephp-swagger-bake/#details","text":"OpenAPI Schema Support Roadmap Swagger uses your existing swagger.yml as a base for adding additional paths and schema. Generates JSON based on the OpenAPI 3 specification. I am still working on implementing the full spec. All Schemas and Paths generated must have the following in your CakePHP Application: App\\Model\\Entity class (for schemas only) App\\Controller class Must be a valid route Three versions of schema will be created: Default with all properties #/components/schemas/Entity Writeable properties #/x-swagger-bake/components/schemas/Entity-Write Readable properties #/x-swagger-bake/components/schemas/Entity-Read Entity Attributes: Hidden attributes will not be visible Primary Keys will be set to read only by default. DateTime fields named created and modified are automatically set to read only per Cake convention. CRUD Responses Index, Edit, Add, and View methods default to an HTTP 200 with the Controllers related Cake Entity schema. Delete defaults to HTTP 204 (no content). Table Validators: Reads in Validator rules such as requirePresence, minLength, maxLength, basic math comparison operators, regex, inList, hasAtLeast, and hasAtMost. Security Scheme Leverages the CakePHP AuthenticationComponent Will automatically set security on operations if a single securityScheme is defined in your swagger.yaml. If more than one security schema exists you will need to use @SwagSecurity . @SwagSecurity takes precedence. SwaggerBake supports the following formats: application/json, application/x-www-form-urlencoded, application/xml, application/hal+json, and application/ld+json SwaggerBake does not document schema associations. If your application includes associations on things like GET requests, you can easily add them into your swagger documentation through the OpenAPI allOf property. Since SwaggerBake works in conjunction with OpenAPI YAML you can easily add a new schema with this association. Below is an example of extending an existing City schema to include a Country association. # in your swagger.yml components : schemas : CityExtended : description : 'City with extended information including Country' type : object allOf : - $ref : '#/components/schemas/City' - type : object properties : country : $ref : '#/components/schemas/Country' Then in your controller action you'd specify the Schema: /** * View method * @Swag\\SwagResponseSchema(refEntity=\"#/components/schemas/CityExtended\") */ public function view ( $id ) { $this -> request -> allowMethod ( 'get' ); $city = $this -> Cities -> get ( $id , [ 'contain' => [ 'Countries' ]]); $this -> set ( compact ( 'cities' )); $this -> viewBuilder () -> setOption ( 'serialize' , 'cities' ); } The demo application includes this and many other examples of usage. Read more about oneOf , anyOf , allOf , and not in the OpenAPI 3 documentation .","title":"Details"},{"location":"cakephp-swagger-bake/#supported-versions","text":"This is built for CakePHP 4.x only. A cake-3.8 option is available, but not supported. Version Cake Version Supported Unit Tests Notes 1.* 4.* Yes Yes Currently supported cake-3.8 3.8.* No Yes See branch cake-3.8. Completely untested and unsupported","title":"Supported Versions"},{"location":"cakephp-swagger-bake/#common-issues","text":"","title":"Common Issues"},{"location":"cakephp-swagger-bake/#swagger-ui","text":"No API definition provided. Verify that swagger.json exists.","title":"Swagger UI"},{"location":"cakephp-swagger-bake/#swaggerbakeruntimeexceptions","text":"Unable to create swagger file. Try creating an empty file first or checking permissions Create the swagger.json manually matching the path in your config/swagger_bake.php file. Output file is not writable Change permissions on your swagger.json file , 764 should do. Controller not found Make sure a controller actually exists for the route resource.","title":"SwaggerBakeRunTimeExceptions"},{"location":"cakephp-swagger-bake/#other-issues","text":"","title":"Other Issues"},{"location":"cakephp-swagger-bake/#missing-actions-missing-paths-in-swagger","text":"By default Cake RESTful resources will only create routes for index, view, add, edit and delete. You can add and remove paths using CakePHPs route resource functionality. Read the Cake Routing documentation which describes in detail how to add, remove, modify, and alter routes.","title":"Missing actions (missing paths) in Swagger"},{"location":"cakephp-swagger-bake/#missing-csrf-token-body","text":"Either disable CSRF protection on your main route in config/routes.php or enable CSRF protection in Swagger UI. The library does not currently support adding this in for you.","title":"Missing CSRF token body"},{"location":"cakephp-swagger-bake/#my-route-isnt-displaying-in-swagger-ui","text":"Make sure the route is properly defined in your config/routes.php file.","title":"My route isn't displaying in Swagger UI"},{"location":"cakephp-swagger-bake/#reporting-issues","text":"This is a new library so please take some steps before reporting issues. You can copy & paste the JSON SwaggerBake outputs into https://editor.swagger.io/ which will automatically convert the JSON into YML and display potential schema issues. Please included the following in your issues a long with a brief description: Steps to Reproduce Actual Outcome Expected Outcome Feature requests are welcomed.","title":"Reporting Issues"},{"location":"cakephp-swagger-bake/#contribute","text":"Send pull requests to help improve this library. You can include SwaggerBake in your primary Cake project as a local source to make developing easier: Make a fork of this repository and clone it to your localhost Remove cnizzardini\\cakephp-swagger-bake from your composer.json Add a paths repository to your composer.json \"minimum-stability\": \"dev\", \"repositories\": [ { \"type\": \"path\", \"url\": \"/absolute/local-path-to/cakephp-swagger-bake\", \"options\": { \"symlink\": true } } ] Run composer require cnizzardini/cakephp-swagger-bake @dev Undo these steps when you're done. Read the full composer documentation on loading from path here: https://getcomposer.org/doc/05-repositories.md#path","title":"Contribute"},{"location":"cakephp-swagger-bake/#coding-standards","text":"Coding standards run as part of CI with Travis. You may run these locally with composer check .","title":"Coding Standards"},{"location":"cakephp-swagger-bake/#unit-tests","text":"vendor/bin/phpunit","title":"Unit Tests"},{"location":"cakephp-swagger-bake/LICENSE/","text":"The MIT License (MIT) Copyright (c) Chris Nizzardini Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"LICENSE"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/","text":"SwaggerBake Annotations SwaggerBake provides some optional Annotations for enhanced functionality. There are core annotations and extended annotations which support other Cake plugins. These can be imported individually or set to an alias as seen below. use SwaggerBake\\Lib\\Annotation as Swag; use SwaggerBake\\Lib\\Extension as SwagExt; Table of Contents Adding Annotations Usage @SwagPaginator @SwagSearch @SwagQuery @SwagForm @SwagDto @SwagDtoQuery @SwagDtoForm @SwagHeader @SwagPathParameter @SwagSecurity @SwagOperation @SwagRequestBody @SwagRequestBodyContent @SwagResponseSchema @SwagPath @SwagEntity @SwagEntityAttribute Adding Annotations Annotations use the doctrine/annotations package. To add a new Annotation simply create a new class using one of the existing annotations as an example. Then add the new annotation to src/Lib/AnnotationLoader.php . Usage You can improve this documentation by submitting PRs. @SwagPaginator Method level annotation for adding CakePHP Paginator query parameters: page, limit, sort, and direction. When specified with no arguments, Paginate.sortableFields will be used to populate sort options. If sortableFields is not defined the controller actions associated Schema properties will be used. You can override the defaults using the sort attribute. Otherwise, a simple text input is rendered ( useSortTextInput=true ). use SwaggerBake\\Lib\\Annotation as Swag ; /** * @Swag\\SwagPaginator # default without attributes should work fine in most cases * @Swag\\SwagPaginator(sort={\"id\",\"name\"}, useSortTextInput=false) # custom example */ public function index () { $employees = $this -> paginate ( $this -> Employees ); $this -> set ( compact ( 'employees' )); $this -> viewBuilder () -> setOption ( 'serialize' , [ 'employees' ]); } OpenAPI: parameters : - name : page in : query schema : type : integer - name : limit in : query schema : type : integer - name : sort in : query schema : type : string enum : - id - name - name : direction in : query schema : type : string enum : - asc - desc @SwagSearch Method level annotation for documenting search parameters using the popular friendsofcake/search plugin. /** * @SwaggerBake\\Lib\\Extension\\CakeSearch\\Annotation\\SwagSearch(tableClass=\"\\App\\Model\\Table\\FilmsTable\", collection=\"default\") */ public function index () { $this -> request -> allowMethod ( 'get' ); $query = $this -> Films -> find ( 'search' , [ 'search' => $this -> request -> getQueryParams (), 'collection' => 'default' ]) -> contain ([ 'Languages' ]); $films = $this -> paginate ( $query ); $this -> set ( compact ( 'films' )); $this -> viewBuilder () -> setOption ( 'serialize' , 'films' ); } Friends Of Cake Search Filter: <? php declare ( strict_types = 1 ); namespace App\\Model\\Filter ; use Search\\Model\\Filter\\FilterCollection ; class FilmsCollection extends FilterCollection { public function initialize () : void { $this -> add ( 'title' , 'Search.Like' , [ 'before' => true , 'after' => true , 'mode' => 'or' , 'comparison' => 'LIKE' , 'wildcardAny' => '*' , 'wildcardOne' => '?' , 'fields' => [ 'title' ], ]) -> add ( 'rating' , 'Search.Value' , [ 'before' => true , 'after' => true , 'mode' => 'or' , 'wildcardAny' => '*' , 'wildcardOne' => '?' , 'fields' => [ 'rating' ], ]); } OpenAPI: parameters : - name : title in : query description : Like title schema : type : string - name : rating in : query description : Value rating schema : type : string @SwagQuery Method level annotation for adding query parameters. Read the comments to see all supported OpenAPI properties. /** * @Swag\\SwagQuery(name=\"one\", required=true, description=\"example description\") * @Swag\\SwagQuery(name=\"two\", type=\"string\", explode=true) * @Swag\\SwagQuery(name=\"three\", enum={\"A\",\"B\",\"C\"}, deprecated=true) * @Swag\\SwagQuery(ref=\"#/x-my-project/components/parameters/my-parameter\") */ public function index () {} OpenAPI: parameters : - name : one in : query description : example description schema : type : string - name : two in : query explode : true schema : type : string - name : three in : query explode : true deprecated : true schema : type : string enum : - A - B - C - $ref : #/x-my-project/components/parameters/my-parameter @SwagForm Method level annotation for adding form data fields. Read the comments to see all supported OpenAPI properties. /** * @Swag\\SwagForm(name=\"one\", type=\"string\", description=\"example\", required=true, enum={\"A\",\"B\"}) * @Swag\\SwagForm(name=\"two\", type=\"integer\", minimum=10, maximum=100, multipleOf=10) * @Swag\\SwagForm(name=\"three\", type=\"string\", minLength=8, maxLength=64, pattern=\"[a-zA-Z]\") */ public function add () {} OpenAPI: requestBody : description : '' content : application/x-www-form-urlencoded : schema : description : Actor Entity type : object properties : one : type : string description : example required : true enum : - A - B two : type : integer minimum : 10 maximum : 100 multipleOf : 10 three : type : string minLength : 8 maxLength : 64 pattern : [ a-zA-Z ] @SwagDto Method level annotation for building query or form parameters from a DataTransferObject. DTOs are more than just a best practice. Using them with SwaggerBake greatly reduces the amount of annotations you need to write. Consider using a DTO in place of SwagQuery or SwagForm. SwagDto uses either SwagDtoProperty or your existing Doc Blocks to build swagger query and post parameters. /** * @Swag\\SwagDto(class=\"\\App\\Dto\\ActorDto\") */ public function index () {} @SwagDtoQuery Property level annotation for use in your SwagDto classes. Read the comments to see all supported properties. class ActorDto { /** * @SwagDtoQuery(name=\"example\", type=\"string\", required=true, enum={\"A\",\"B\"}) */ private $example ; @SwagDtoForm Property level annotation for use in your SwagDto classes. Read the comments to see all supported properties. class ActorDto { /** * @SwagDtoForm(name=\"example\", type=\"integer\", required=true, minimum=10, maximum=100) */ private $example ; @SwagHeader Method level annotation for adding header parameters. Read the comments to see all supported OpenAPI properties. /** * @Swag\\SwagHeader(name=\"X-HEAD-ATTRIBUTE\", type=\"string\", description=\"example\") * @Swag\\SwagHeader(ref=\"#/x-my-project/components/parameters/my-header\") */ public function index () {} OpenAPI: parameters : - name : X-HEAD-ATTRIBUTE in : header description : summary schema : type : string - $ref : #/x-my-project/components/parameters/my-header @SwagPathParameter Method level annotation for modifying path parameters. Read the comments to see all supported OpenAPI properties. This is for modifying existing path parameters only. Path parameters must first be defined in your routes file. /** * @Swag\\SwagPathParameter(name=\"id\", type=\"integer\", format=\"int64\", description=\"ID\") */ public function view ( $id ) {} OpenAPI: parameters : - name : id required : true schema : description : ID type : integer format : int64 @SwagSecurity Method level annotation for adding authentication requirements. This annotation takes precedence over settings that SwaggerBake gathers from AuthenticationComponent. See the main documentation for more information. /** * @Swag\\SwagSecurity(name=\"BearerAuth\", scopes={\"Read\",\"Write\"}) */ public function index () {} @SwagOperation Method level annotation for OpenApi Operations. Read the comments for examples and further explanations. /** * @Swag\\SwagOperation(isVisible=true, tagNames={\"Custom\",\"Tags\"}, showPut=true) */ public function index () {} OpenAPI: put : tags : - Custom - Tags @SwagRequestBody Method level annotation for describing request body. Set ignoreCakeSchema for full control over request body. /** * @Swag\\SwagRequestBody(description=\"my description\", required=true, ignoreCakeSchema=true) */ public function index () {} @SwagRequestBodyContent Method level annotation for describing custom content in request body. The mimeTypes parameter is optional. If empty, all mimeTypes defined as requestAccepts in your swagger_bake.php will be used. This will only show writeable properties. mimeType has been deprecated in >= v1.5, use array form with mimeTypes /** * @Swag\\SwagRequestBodyContent(refEntity=\"#/components/schemas/Actor\", mimeTypes={\"application/json\"}) */ public function index () {} OpenAPI: requestBody : description : '' content : application/json : schema : description : Actor Entity type : object properties : first_name : type : string minLength : 1 maxLength : 45 last_name : type : string minLength : 1 maxLength : 45 @SwagResponseSchema Method level annotation for defining response schema. Read the comments to see all supported properties and additional examples. mimeType is deprecated in >= v1.5, use mimeTypes as an array. httpCode is deprecated in >= v1.3, use statusCode /** * @Swag\\SwagResponseSchema(refEntity=\"#/components/schemas/Actor\", description=\"Summary\", statusCode=\"200\") */ public function view () {} OpenAPI: responses : '200' : # note: default is 200 content : application/json : # note: uses your default mime type since none was specified schema : description : My summary type : object # note: `object` is default when using refEntity $ref : '#/components/schemas/Actor' Defining a single mimeType and 400-409 status code range: /** * @Swag\\SwagResponseSchema(refEntity=\"#/components/schemas/Exception\", mimeTypes={\"application/xml\"}, statusCode=\"40x\") */ OpenAPI: '40x' : content : application/xml : schema : type : object items : $ref : '#/components/schemas/Exception' Defining an array of objects: /** * @Swag\\SwagResponseSchema(schemaItems={\"$ref\"=\"#/components/schemas/Actor\"}) */ OpenAPI: '200' : content : application/json : schema : type : array items : $ref : '#/components/schemas/Actor' @SwagPath Class level annotation for exposing controllers to Swagger UI. You can hide entire controllers with this annotation. /** * @Swag\\SwagPath(isVisible=false, description=\"optional description\", summary=\"operational summary\") */ class UsersController extends AppController { @SwagEntity Class level annotation for exposing entities to Swagger UI. By default, all entities with routes will display as Swagger schema. You can hide a schema or display a schema that does not have an associated route. /** * @Swag\\SwagEntity(isVisible=false, title=\"optional title\", description=\"optional description\") */ class Employee extends Entity { @SwagEntityAttribute Class level annotation for customizing Schema Attributes. Read the comments to see all supported OpenAPI properties. Note that the attribute does not have to exist in your entity. You can add adhoc attributes as needed or Virtual Fields . /** * @Swag\\SwagEntityAttribute(name=\"example_one\", type=\"string\", minLength=5, maxLength=10) * @Swag\\SwagEntityAttribute(name=\"example_two\", type=\"string\", enum={\"PG\",\"R\"}, required=true) * @Swag\\SwagEntityAttribute(name=\"example_virtual_field\", type=\"string\", readOnly=true) */ class Employee extends Entity { OpenAPI: yaml example_one: type: string minLength: 5 maxLength: 10 example_two: type: string enum: - PG - R required: true example_virtual_field: type: string readOnly: true","title":"SwaggerBake Annotations"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swaggerbake-annotations","text":"SwaggerBake provides some optional Annotations for enhanced functionality. There are core annotations and extended annotations which support other Cake plugins. These can be imported individually or set to an alias as seen below. use SwaggerBake\\Lib\\Annotation as Swag; use SwaggerBake\\Lib\\Extension as SwagExt;","title":"SwaggerBake Annotations"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#table-of-contents","text":"Adding Annotations Usage @SwagPaginator @SwagSearch @SwagQuery @SwagForm @SwagDto @SwagDtoQuery @SwagDtoForm @SwagHeader @SwagPathParameter @SwagSecurity @SwagOperation @SwagRequestBody @SwagRequestBodyContent @SwagResponseSchema @SwagPath @SwagEntity @SwagEntityAttribute","title":"Table of Contents"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#adding-annotations","text":"Annotations use the doctrine/annotations package. To add a new Annotation simply create a new class using one of the existing annotations as an example. Then add the new annotation to src/Lib/AnnotationLoader.php .","title":"Adding Annotations"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#usage","text":"You can improve this documentation by submitting PRs.","title":"Usage"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagpaginator","text":"Method level annotation for adding CakePHP Paginator query parameters: page, limit, sort, and direction. When specified with no arguments, Paginate.sortableFields will be used to populate sort options. If sortableFields is not defined the controller actions associated Schema properties will be used. You can override the defaults using the sort attribute. Otherwise, a simple text input is rendered ( useSortTextInput=true ). use SwaggerBake\\Lib\\Annotation as Swag ; /** * @Swag\\SwagPaginator # default without attributes should work fine in most cases * @Swag\\SwagPaginator(sort={\"id\",\"name\"}, useSortTextInput=false) # custom example */ public function index () { $employees = $this -> paginate ( $this -> Employees ); $this -> set ( compact ( 'employees' )); $this -> viewBuilder () -> setOption ( 'serialize' , [ 'employees' ]); } OpenAPI: parameters : - name : page in : query schema : type : integer - name : limit in : query schema : type : integer - name : sort in : query schema : type : string enum : - id - name - name : direction in : query schema : type : string enum : - asc - desc","title":"@SwagPaginator"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagsearch","text":"Method level annotation for documenting search parameters using the popular friendsofcake/search plugin. /** * @SwaggerBake\\Lib\\Extension\\CakeSearch\\Annotation\\SwagSearch(tableClass=\"\\App\\Model\\Table\\FilmsTable\", collection=\"default\") */ public function index () { $this -> request -> allowMethod ( 'get' ); $query = $this -> Films -> find ( 'search' , [ 'search' => $this -> request -> getQueryParams (), 'collection' => 'default' ]) -> contain ([ 'Languages' ]); $films = $this -> paginate ( $query ); $this -> set ( compact ( 'films' )); $this -> viewBuilder () -> setOption ( 'serialize' , 'films' ); } Friends Of Cake Search Filter: <? php declare ( strict_types = 1 ); namespace App\\Model\\Filter ; use Search\\Model\\Filter\\FilterCollection ; class FilmsCollection extends FilterCollection { public function initialize () : void { $this -> add ( 'title' , 'Search.Like' , [ 'before' => true , 'after' => true , 'mode' => 'or' , 'comparison' => 'LIKE' , 'wildcardAny' => '*' , 'wildcardOne' => '?' , 'fields' => [ 'title' ], ]) -> add ( 'rating' , 'Search.Value' , [ 'before' => true , 'after' => true , 'mode' => 'or' , 'wildcardAny' => '*' , 'wildcardOne' => '?' , 'fields' => [ 'rating' ], ]); } OpenAPI: parameters : - name : title in : query description : Like title schema : type : string - name : rating in : query description : Value rating schema : type : string","title":"@SwagSearch"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagquery","text":"Method level annotation for adding query parameters. Read the comments to see all supported OpenAPI properties. /** * @Swag\\SwagQuery(name=\"one\", required=true, description=\"example description\") * @Swag\\SwagQuery(name=\"two\", type=\"string\", explode=true) * @Swag\\SwagQuery(name=\"three\", enum={\"A\",\"B\",\"C\"}, deprecated=true) * @Swag\\SwagQuery(ref=\"#/x-my-project/components/parameters/my-parameter\") */ public function index () {} OpenAPI: parameters : - name : one in : query description : example description schema : type : string - name : two in : query explode : true schema : type : string - name : three in : query explode : true deprecated : true schema : type : string enum : - A - B - C - $ref : #/x-my-project/components/parameters/my-parameter","title":"@SwagQuery"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagform","text":"Method level annotation for adding form data fields. Read the comments to see all supported OpenAPI properties. /** * @Swag\\SwagForm(name=\"one\", type=\"string\", description=\"example\", required=true, enum={\"A\",\"B\"}) * @Swag\\SwagForm(name=\"two\", type=\"integer\", minimum=10, maximum=100, multipleOf=10) * @Swag\\SwagForm(name=\"three\", type=\"string\", minLength=8, maxLength=64, pattern=\"[a-zA-Z]\") */ public function add () {} OpenAPI: requestBody : description : '' content : application/x-www-form-urlencoded : schema : description : Actor Entity type : object properties : one : type : string description : example required : true enum : - A - B two : type : integer minimum : 10 maximum : 100 multipleOf : 10 three : type : string minLength : 8 maxLength : 64 pattern : [ a-zA-Z ]","title":"@SwagForm"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagdto","text":"Method level annotation for building query or form parameters from a DataTransferObject. DTOs are more than just a best practice. Using them with SwaggerBake greatly reduces the amount of annotations you need to write. Consider using a DTO in place of SwagQuery or SwagForm. SwagDto uses either SwagDtoProperty or your existing Doc Blocks to build swagger query and post parameters. /** * @Swag\\SwagDto(class=\"\\App\\Dto\\ActorDto\") */ public function index () {}","title":"@SwagDto"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagdtoquery","text":"Property level annotation for use in your SwagDto classes. Read the comments to see all supported properties. class ActorDto { /** * @SwagDtoQuery(name=\"example\", type=\"string\", required=true, enum={\"A\",\"B\"}) */ private $example ;","title":"@SwagDtoQuery"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagdtoform","text":"Property level annotation for use in your SwagDto classes. Read the comments to see all supported properties. class ActorDto { /** * @SwagDtoForm(name=\"example\", type=\"integer\", required=true, minimum=10, maximum=100) */ private $example ;","title":"@SwagDtoForm"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagheader","text":"Method level annotation for adding header parameters. Read the comments to see all supported OpenAPI properties. /** * @Swag\\SwagHeader(name=\"X-HEAD-ATTRIBUTE\", type=\"string\", description=\"example\") * @Swag\\SwagHeader(ref=\"#/x-my-project/components/parameters/my-header\") */ public function index () {} OpenAPI: parameters : - name : X-HEAD-ATTRIBUTE in : header description : summary schema : type : string - $ref : #/x-my-project/components/parameters/my-header","title":"@SwagHeader"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagpathparameter","text":"Method level annotation for modifying path parameters. Read the comments to see all supported OpenAPI properties. This is for modifying existing path parameters only. Path parameters must first be defined in your routes file. /** * @Swag\\SwagPathParameter(name=\"id\", type=\"integer\", format=\"int64\", description=\"ID\") */ public function view ( $id ) {} OpenAPI: parameters : - name : id required : true schema : description : ID type : integer format : int64","title":"@SwagPathParameter"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagsecurity","text":"Method level annotation for adding authentication requirements. This annotation takes precedence over settings that SwaggerBake gathers from AuthenticationComponent. See the main documentation for more information. /** * @Swag\\SwagSecurity(name=\"BearerAuth\", scopes={\"Read\",\"Write\"}) */ public function index () {}","title":"@SwagSecurity"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagoperation","text":"Method level annotation for OpenApi Operations. Read the comments for examples and further explanations. /** * @Swag\\SwagOperation(isVisible=true, tagNames={\"Custom\",\"Tags\"}, showPut=true) */ public function index () {} OpenAPI: put : tags : - Custom - Tags","title":"@SwagOperation"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagrequestbody","text":"Method level annotation for describing request body. Set ignoreCakeSchema for full control over request body. /** * @Swag\\SwagRequestBody(description=\"my description\", required=true, ignoreCakeSchema=true) */ public function index () {}","title":"@SwagRequestBody"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagrequestbodycontent","text":"Method level annotation for describing custom content in request body. The mimeTypes parameter is optional. If empty, all mimeTypes defined as requestAccepts in your swagger_bake.php will be used. This will only show writeable properties. mimeType has been deprecated in >= v1.5, use array form with mimeTypes /** * @Swag\\SwagRequestBodyContent(refEntity=\"#/components/schemas/Actor\", mimeTypes={\"application/json\"}) */ public function index () {} OpenAPI: requestBody : description : '' content : application/json : schema : description : Actor Entity type : object properties : first_name : type : string minLength : 1 maxLength : 45 last_name : type : string minLength : 1 maxLength : 45","title":"@SwagRequestBodyContent"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagresponseschema","text":"Method level annotation for defining response schema. Read the comments to see all supported properties and additional examples. mimeType is deprecated in >= v1.5, use mimeTypes as an array. httpCode is deprecated in >= v1.3, use statusCode /** * @Swag\\SwagResponseSchema(refEntity=\"#/components/schemas/Actor\", description=\"Summary\", statusCode=\"200\") */ public function view () {} OpenAPI: responses : '200' : # note: default is 200 content : application/json : # note: uses your default mime type since none was specified schema : description : My summary type : object # note: `object` is default when using refEntity $ref : '#/components/schemas/Actor' Defining a single mimeType and 400-409 status code range: /** * @Swag\\SwagResponseSchema(refEntity=\"#/components/schemas/Exception\", mimeTypes={\"application/xml\"}, statusCode=\"40x\") */ OpenAPI: '40x' : content : application/xml : schema : type : object items : $ref : '#/components/schemas/Exception' Defining an array of objects: /** * @Swag\\SwagResponseSchema(schemaItems={\"$ref\"=\"#/components/schemas/Actor\"}) */ OpenAPI: '200' : content : application/json : schema : type : array items : $ref : '#/components/schemas/Actor'","title":"@SwagResponseSchema"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagpath","text":"Class level annotation for exposing controllers to Swagger UI. You can hide entire controllers with this annotation. /** * @Swag\\SwagPath(isVisible=false, description=\"optional description\", summary=\"operational summary\") */ class UsersController extends AppController {","title":"@SwagPath"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagentity","text":"Class level annotation for exposing entities to Swagger UI. By default, all entities with routes will display as Swagger schema. You can hide a schema or display a schema that does not have an associated route. /** * @Swag\\SwagEntity(isVisible=false, title=\"optional title\", description=\"optional description\") */ class Employee extends Entity {","title":"@SwagEntity"},{"location":"cakephp-swagger-bake/src/Lib/Annotation/#swagentityattribute","text":"Class level annotation for customizing Schema Attributes. Read the comments to see all supported OpenAPI properties. Note that the attribute does not have to exist in your entity. You can add adhoc attributes as needed or Virtual Fields . /** * @Swag\\SwagEntityAttribute(name=\"example_one\", type=\"string\", minLength=5, maxLength=10) * @Swag\\SwagEntityAttribute(name=\"example_two\", type=\"string\", enum={\"PG\",\"R\"}, required=true) * @Swag\\SwagEntityAttribute(name=\"example_virtual_field\", type=\"string\", readOnly=true) */ class Employee extends Entity { OpenAPI: yaml example_one: type: string minLength: 5 maxLength: 10 example_two: type: string enum: - PG - R required: true example_virtual_field: type: string readOnly: true","title":"@SwagEntityAttribute"},{"location":"cakephp-swagger-bake/src/Lib/Extension/","text":"SwaggerBake Extensions Extensions to SwaggerBake can be added through the use of events. See CakeSearch for an example. You may submit extensions as PRs to this project or simply create extended functionality within your own project using the event system. Supported Events The SwaggerBake.Operation.created is dispatched each time a new Operation is created. Simply listen for the event: EventManager :: instance () -> on ( 'SwaggerBake.Operation.created' , function ( Event $event ) { // your code }); Adding your Extension to the SwaggerBake project Your extension must implement ExtensionInterface. Read the interfaces comments and refer to the CakeSearch extension for additional insight. Add your extension to the EXTENSIONS constant in src/Lib/ExtensionLoader.php . Create necessary unit tests tests/TestCase/Lib/Extension . Submit your PR!","title":"SwaggerBake Extensions"},{"location":"cakephp-swagger-bake/src/Lib/Extension/#swaggerbake-extensions","text":"Extensions to SwaggerBake can be added through the use of events. See CakeSearch for an example. You may submit extensions as PRs to this project or simply create extended functionality within your own project using the event system.","title":"SwaggerBake Extensions"},{"location":"cakephp-swagger-bake/src/Lib/Extension/#supported-events","text":"The SwaggerBake.Operation.created is dispatched each time a new Operation is created. Simply listen for the event: EventManager :: instance () -> on ( 'SwaggerBake.Operation.created' , function ( Event $event ) { // your code });","title":"Supported Events"},{"location":"cakephp-swagger-bake/src/Lib/Extension/#adding-your-extension-to-the-swaggerbake-project","text":"Your extension must implement ExtensionInterface. Read the interfaces comments and refer to the CakeSearch extension for additional insight. Add your extension to the EXTENSIONS constant in src/Lib/ExtensionLoader.php . Create necessary unit tests tests/TestCase/Lib/Extension . Submit your PR!","title":"Adding your Extension to the SwaggerBake project"},{"location":"collection-view/","text":"MixerAPI CollectionView Alpha stage library A simple Collection View for displaying configurable pagination meta data in JSON or XML collection responses. Table of Contents Installation Setup Usage Configuration Installation composer require mixerapi/collection-view bin/cake plugin load MixerApi/CollectionView Alternatively after composer installing you can manually load the plugin in your Application: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/CollectionView' ); } Setup Your controllers must be using the RequestHandler component. This is typically loaded in your AppController . # src/Controller/AppController.php public function initialize () : void { parent :: initialize (); $this -> loadComponent ( 'RequestHandler' ); // other logic... } Usage That's it, you're done. Perform application/xml or application/json requests as normal. You may also request by .xml or .json extensions (assuming you've enabled them in your config/routes.php ). This plugin will only modify collections (e.g. controller::index action) requests, not item (e.g. controller::view action) requests. JSON Sample: { \"collection\" : { \"url\" : \"\\/actors\" , \"count\" : 2 , \"total\" : 20 , \"next\" : \"\\/?page=2\" , \"prev\" : \"\" , \"first\" : \"\" , \"last\" : \"\\/?page=10\" }, \"data\" : [ { \"id\" : 1 , \"first_name\" : \"PENELOPE\" , \"last_name\" : \"GUINESS\" , \"modified\" : \"2006-02-15T04:34:33+00:00\" , \"films\" : [ { \"id\" : 1 , \"title\" : \"ACADEMY DINOSAUR\" , \"description\" : \"A Epic Drama of a Feminist And a Mad Scientist who must Battle a Teacher in The Canadian Rockies\" , \"release_year\" : \"2006\" , \"language_id\" : 1 , \"rental_duration\" : 6 , \"length\" : 86 , \"rating\" : \"PG\" , \"special_features\" : \"Deleted Scenes,Behind the Scenes\" , \"modified\" : \"2006-02-15T05:03:42+00:00\" } ] } ] } XML Sample: <response> <collection> <url> /actors </url> <count> 2 </count> <total> 20 </total> <next> /?page=2 </next> <prev/> <first/> <last> /?page=10 </last> </collection> <data> <id> 1 </id> <first_name> PENELOPE </first_name> <last_name> GUINESS </last_name> <modified> 2/15/06, 4:34 AM </modified> <films> <id> 1 </id> <title> ACADEMY DINOSAUR </title> <description> A Epic Drama of a Feminist And a Mad Scientist who must Battle a Teacher in The Canadian Rockies </description> <release_year> 2006 </release_year> <language_id> 1 </language_id> <rental_duration> 6 </rental_duration> <length> 86 </length> <rating> PG </rating> <special_features> Deleted Scenes,Behind the Scenes </special_features> <modified> 2/15/06, 5:03 AM </modified> </films> </data> </response> Configuration This is optional. You can alter the names of the response keys, simply create a config/collection_view.php file. Using the example below we can change the collection key to pagination , data to items , and alter some key names within our new pagination object. Just keep the mapped items {{names}} as-is. return [ 'CollectionView' => [ 'pagination' => '{{collection}}' , // array that holds pagination data 'pagination.url' => '{{url}}' , // url of current page 'pagination.pageCount' => '{{count}}' , // count on page 'pagination.totalCount' => '{{total}}' , // total items 'pagination.next' => '{{next}}' , // next page url 'pagination.prev' => '{{prev}}' , // previous page url 'pagination.first' => '{{first}}' , // first page url 'pagination.last' => '{{last}}' , // last page url 'items' => '{{data}}' , // the collection of data ] ]; Unit Tests vendor/bin/phpunit Code Standards composer check","title":"MixerAPI CollectionView"},{"location":"collection-view/#mixerapi-collectionview","text":"Alpha stage library A simple Collection View for displaying configurable pagination meta data in JSON or XML collection responses.","title":"MixerAPI CollectionView"},{"location":"collection-view/#table-of-contents","text":"Installation Setup Usage Configuration","title":"Table of Contents"},{"location":"collection-view/#installation","text":"composer require mixerapi/collection-view bin/cake plugin load MixerApi/CollectionView Alternatively after composer installing you can manually load the plugin in your Application: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/CollectionView' ); }","title":"Installation"},{"location":"collection-view/#setup","text":"Your controllers must be using the RequestHandler component. This is typically loaded in your AppController . # src/Controller/AppController.php public function initialize () : void { parent :: initialize (); $this -> loadComponent ( 'RequestHandler' ); // other logic... }","title":"Setup"},{"location":"collection-view/#usage","text":"That's it, you're done. Perform application/xml or application/json requests as normal. You may also request by .xml or .json extensions (assuming you've enabled them in your config/routes.php ). This plugin will only modify collections (e.g. controller::index action) requests, not item (e.g. controller::view action) requests. JSON Sample: { \"collection\" : { \"url\" : \"\\/actors\" , \"count\" : 2 , \"total\" : 20 , \"next\" : \"\\/?page=2\" , \"prev\" : \"\" , \"first\" : \"\" , \"last\" : \"\\/?page=10\" }, \"data\" : [ { \"id\" : 1 , \"first_name\" : \"PENELOPE\" , \"last_name\" : \"GUINESS\" , \"modified\" : \"2006-02-15T04:34:33+00:00\" , \"films\" : [ { \"id\" : 1 , \"title\" : \"ACADEMY DINOSAUR\" , \"description\" : \"A Epic Drama of a Feminist And a Mad Scientist who must Battle a Teacher in The Canadian Rockies\" , \"release_year\" : \"2006\" , \"language_id\" : 1 , \"rental_duration\" : 6 , \"length\" : 86 , \"rating\" : \"PG\" , \"special_features\" : \"Deleted Scenes,Behind the Scenes\" , \"modified\" : \"2006-02-15T05:03:42+00:00\" } ] } ] } XML Sample: <response> <collection> <url> /actors </url> <count> 2 </count> <total> 20 </total> <next> /?page=2 </next> <prev/> <first/> <last> /?page=10 </last> </collection> <data> <id> 1 </id> <first_name> PENELOPE </first_name> <last_name> GUINESS </last_name> <modified> 2/15/06, 4:34 AM </modified> <films> <id> 1 </id> <title> ACADEMY DINOSAUR </title> <description> A Epic Drama of a Feminist And a Mad Scientist who must Battle a Teacher in The Canadian Rockies </description> <release_year> 2006 </release_year> <language_id> 1 </language_id> <rental_duration> 6 </rental_duration> <length> 86 </length> <rating> PG </rating> <special_features> Deleted Scenes,Behind the Scenes </special_features> <modified> 2/15/06, 5:03 AM </modified> </films> </data> </response>","title":"Usage"},{"location":"collection-view/#configuration","text":"This is optional. You can alter the names of the response keys, simply create a config/collection_view.php file. Using the example below we can change the collection key to pagination , data to items , and alter some key names within our new pagination object. Just keep the mapped items {{names}} as-is. return [ 'CollectionView' => [ 'pagination' => '{{collection}}' , // array that holds pagination data 'pagination.url' => '{{url}}' , // url of current page 'pagination.pageCount' => '{{count}}' , // count on page 'pagination.totalCount' => '{{total}}' , // total items 'pagination.next' => '{{next}}' , // next page url 'pagination.prev' => '{{prev}}' , // previous page url 'pagination.first' => '{{first}}' , // first page url 'pagination.last' => '{{last}}' , // last page url 'items' => '{{data}}' , // the collection of data ] ];","title":"Configuration"},{"location":"collection-view/#unit-tests","text":"vendor/bin/phpunit","title":"Unit Tests"},{"location":"collection-view/#code-standards","text":"composer check","title":"Code Standards"},{"location":"exception-render/","text":"MixerAPI ExceptionRender Note: This is an alpha stage plugin This plugin handles rendering entity validation errors and other exceptions for your API. Adds validation errors to the response for failed save operations (post, put, and patch) Adds the short name of the Exception thrown to the response Table of Contents Installation Setup Usage Installation composer require mixerapi/exception-render bin/cake plugin load MixerApi/ExceptionRender Alternatively after composer installing you can manually load the plugin in your Application: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/ExceptionRender' ); } Setup In your config/app.php file change the default exceptionRenderer : 'Error' => [ 'errorLevel' => E_ALL , 'exceptionRenderer' => MixerApi\\ExceptionRender\\MixerApiExceptionRenderer :: class , 'skipLog' => [], 'log' => true , 'trace' => true , ], Usage Define your Validations as normal in your Table classes and MixerApiExceptionRenderer handles the rest by attaching a listener to the afterMarshall event which fires when request data is merged into entities during patchEntity() or newEntity() calls. If a validation fails then a ValidationException is thrown and rendered with an HTTP 422 status code. Example controller action: public function add () { $this -> request -> allowMethod ( 'post' ); $actor = $this -> Actors -> newEmptyEntity (); $actor = $this -> Actors -> patchEntity ( $actor , $this -> request -> getData ()); // potential ValidationException here if ( $this -> Actors -> save ( $actor )) { $this -> viewBuilder () -> setOption ( 'serialize' , 'actor' ); $this -> set ( 'actor' , $actor ); return ; } throw new \\Exception ( \"Record failed to save\" ); } Output: { \"exception\" : \"ValidationException\" , \"message\" : \"Error saving resource `Actor`\" , \"url\" : \"/actors\" , \"code\" : 422 , \"violations\" : [ { \"propertyPath\" : \"first_name\" , \"messages\" : [ { \"rule\" : \"_required\" , \"message\" : \"This field is required\" } ] }, { \"propertyPath\" : \"last_name\" , \"messages\" : [ { \"rule\" : \"_required\" , \"message\" : \"This field is required\" } ] } ] } Using the controller example from above, we can catch the exception if desired and perform additional logic: try { $actor = $this -> Actors -> newEmptyEntity (); $actor = $this -> Actors -> patchEntity ( $actor , $this -> request -> getData ()); } catch ( \\MixerApi\\ExceptionRender\\ValidationException $e ) { // do something here } Exceptions For non-validation based exceptions, even your projects own custom exceptions, the output is similar to CakePHP native output with the addition of an exception attribute. For example, a MethodNotAllowedException would result in: { \"exception\" : \"MethodNotAllowedException\" , \"message\" : \"Your exception message here\" , \"url\" : \"/actors\" , \"code\" : 405 } If for instance you have a custom exception that is thrown, such as InventoryExceededException , you would see: { \"exception\" : \"InventoryExceededException\" , \"message\" : \"No inventory exists\" , \"url\" : \"/requested-url\" , \"code\" : 500 } Providing an Exception name, in conjunction with the status code already provided by CakePHP, enables API clients to tailor their exception handling. Unit Tests vendor/bin/phpunit Code Standards composer check","title":"MixerAPI ExceptionRender"},{"location":"exception-render/#mixerapi-exceptionrender","text":"Note: This is an alpha stage plugin This plugin handles rendering entity validation errors and other exceptions for your API. Adds validation errors to the response for failed save operations (post, put, and patch) Adds the short name of the Exception thrown to the response","title":"MixerAPI ExceptionRender"},{"location":"exception-render/#table-of-contents","text":"Installation Setup Usage","title":"Table of Contents"},{"location":"exception-render/#installation","text":"composer require mixerapi/exception-render bin/cake plugin load MixerApi/ExceptionRender Alternatively after composer installing you can manually load the plugin in your Application: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/ExceptionRender' ); }","title":"Installation"},{"location":"exception-render/#setup","text":"In your config/app.php file change the default exceptionRenderer : 'Error' => [ 'errorLevel' => E_ALL , 'exceptionRenderer' => MixerApi\\ExceptionRender\\MixerApiExceptionRenderer :: class , 'skipLog' => [], 'log' => true , 'trace' => true , ],","title":"Setup"},{"location":"exception-render/#usage","text":"Define your Validations as normal in your Table classes and MixerApiExceptionRenderer handles the rest by attaching a listener to the afterMarshall event which fires when request data is merged into entities during patchEntity() or newEntity() calls. If a validation fails then a ValidationException is thrown and rendered with an HTTP 422 status code. Example controller action: public function add () { $this -> request -> allowMethod ( 'post' ); $actor = $this -> Actors -> newEmptyEntity (); $actor = $this -> Actors -> patchEntity ( $actor , $this -> request -> getData ()); // potential ValidationException here if ( $this -> Actors -> save ( $actor )) { $this -> viewBuilder () -> setOption ( 'serialize' , 'actor' ); $this -> set ( 'actor' , $actor ); return ; } throw new \\Exception ( \"Record failed to save\" ); } Output: { \"exception\" : \"ValidationException\" , \"message\" : \"Error saving resource `Actor`\" , \"url\" : \"/actors\" , \"code\" : 422 , \"violations\" : [ { \"propertyPath\" : \"first_name\" , \"messages\" : [ { \"rule\" : \"_required\" , \"message\" : \"This field is required\" } ] }, { \"propertyPath\" : \"last_name\" , \"messages\" : [ { \"rule\" : \"_required\" , \"message\" : \"This field is required\" } ] } ] } Using the controller example from above, we can catch the exception if desired and perform additional logic: try { $actor = $this -> Actors -> newEmptyEntity (); $actor = $this -> Actors -> patchEntity ( $actor , $this -> request -> getData ()); } catch ( \\MixerApi\\ExceptionRender\\ValidationException $e ) { // do something here }","title":"Usage"},{"location":"exception-render/#exceptions","text":"For non-validation based exceptions, even your projects own custom exceptions, the output is similar to CakePHP native output with the addition of an exception attribute. For example, a MethodNotAllowedException would result in: { \"exception\" : \"MethodNotAllowedException\" , \"message\" : \"Your exception message here\" , \"url\" : \"/actors\" , \"code\" : 405 } If for instance you have a custom exception that is thrown, such as InventoryExceededException , you would see: { \"exception\" : \"InventoryExceededException\" , \"message\" : \"No inventory exists\" , \"url\" : \"/requested-url\" , \"code\" : 500 } Providing an Exception name, in conjunction with the status code already provided by CakePHP, enables API clients to tailor their exception handling.","title":"Exceptions"},{"location":"exception-render/#unit-tests","text":"vendor/bin/phpunit","title":"Unit Tests"},{"location":"exception-render/#code-standards","text":"composer check","title":"Code Standards"},{"location":"hal-view/","text":"MixerApi HAL View Note, this is a beta library A Hypertext Application Language ( HAL+JSON ) View for CakePHP. This plugin supports links, pagination, and embedded resources. Once setup any request with application/hal+json will be rendered by this plugin. Table of Contents Installation Setup Usage Serializing Installation composer require mixerapi/hal-view bin/cake plugin load MixerApi/HalView Alternatively after composer installing you can manually load the plugin in your Application: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/HalView' ); } Setup Your controllers must be using the RequestHandler component. This is typically loaded in your AppController . # src/Controller/AppController.php public function initialize () : void { parent :: initialize (); $this -> loadComponent ( 'RequestHandler' ); // other logic... } Usage For _link.self.href support you will need to implement MixerApi\\HalView\\HalResourceInterface on entities that you want to expose as HAL resources. This informs the plugin that the Entity should be treated as a HAL resource and provides the mapper with a _link.self.href URL. Example: <? php declare ( strict_types = 1 ); namespace App\\Model\\Entity ; use Cake\\ORM\\Entity ; use MixerApi\\HalView\\HalResourceInterface ; use Cake\\Datasource\\EntityInterface ; class Actor extends Entity implements HalResourceInterface { // your various properties and logic /** * @param EntityInterface $entity * @return array|\\string[][] */ public function getHalLinks ( EntityInterface $entity ) : array { return [ 'self' => [ 'href' => '/actors/' . $entity -> get ( 'id' ) ] ]; } } Now an HTTP GET to the /actors/1 endpoint will render HAL using the CakePHP native serialization process: #src/Controller/ActorsController.php public function view ( $id = null ) { $this -> request -> allowMethod ( 'get' ); $actor = $this -> Actors -> get ( $id , [ 'contain' => [ 'Films' ], ]); $this -> set ( 'actor' , $actor ); $this -> viewBuilder () -> setOption ( 'serialize' , 'actor' ); } Output: { \"_links\" : { \"self\" : { \"href\" : \"/actors/149\" } }, \"id\" : 149 , \"first_name\" : \"RUSSELL\" , \"last_name\" : \"TEMPLE\" , \"modified\" : \"2006-02-15T04:34:33+00:00\" , \"_embedded\" : { \"films\" : [ { \"id\" : 53 , \"title\" : \"BANG KWAI\" , \"description\" : \"A Epic Drama of a Madman And a Cat who must Face a A Shark in An Abandoned Amusement Park\" , \"release_year\" : \"2006\" , \"language_id\" : 1 , \"rental_duration\" : 5 , \"rental_rate\" : \"2.99\" , \"length\" : 87 , \"replacement_cost\" : \"25.99\" , \"rating\" : \"NC-17\" , \"special_features\" : \"Commentaries,Deleted Scenes,Behind the Scenes\" , \"modified\" : \"2006-02-15T05:03:42+00:00\" \"_links\" : { \"self\" : { \"href\" : \"/films/53\" } } } ] } } If your Entity does not implement the interface it will still be returned as HAL resource when serialized, but minus the _links property. Collection requests will work without this interface as well, example: #src/Controller/ActorsController.php public function index () { $this -> request -> allowMethod ( 'get' ); $actors = $this -> paginate ( $this -> Actors , [ 'contain' => [ 'Films' ], ]); $this -> set ( compact ( 'actors' )); $this -> viewBuilder () -> setOption ( 'serialize' , 'actors' ); } Output: { \"_links\" : { \"self\" : { \"href\" : \"/actors?page=3\" }, \"next\" : { \"href\" : \"/actors?page=4\" }, \"prev\" : { \"href\" : \"/actors?page=2\" }, \"first\" : { \"href\" : \"/actors?page=1\" }, \"last\" : { \"href\" : \"/actors?page=11\" } }, \"count\" : 20 , \"total\" : 207 , \"_embedded\" : { \"actors\" : [ { \"id\" : 1 , \"first_name\" : \"PENELOPE\" , \"last_name\" : \"GUINESS\" , \"modified\" : \"2006-02-15T04:34:33+00:00\" \"_embedded\" : { \"films\" : [ { \"id\" : 1 , \"title\" : \"ACADEMY DINOSAUR\" , \"description\" : \"A Epic Drama of a Feminist And a Mad Scientist who must Battle a Teacher in The Canadian Rockies\" , \"release_year\" : \"2006\" , \"language_id\" : 1 , \"rental_duration\" : 6 , \"rental_rate\" : \"0.99\" , \"length\" : 86 , \"replacement_cost\" : \"20.99\" , \"rating\" : \"PG\" , \"special_features\" : \"Deleted Scenes,Behind the Scenes\" , \"modified\" : \"2006-02-15T05:03:42+00:00\" } ] } } ] } } If the Actor and Film entities were implementing MixerApi\\HalView\\HalResourceInterface then the example above would include the _links property for each serialized entity. Try it out for yourself: # json curl -X GET \"http://localhost:8765/actors\" -H \"accept: application/hal+json\" Serializing Optionally, you can manually serialize data into HAL using JsonSerializer . This is the same class that the main HalJsonView uses. Example: use MixerApi\\HalView\\JsonSerializer ; # json $json = ( new JsonSerializer ( $data )) -> asJson ( JSON_PRETTY_PRINT ); // asJson argument is optional # array $hal = ( new JsonSerializer ( $data )) -> getData (); # json with `_links.self.href` and pagination meta data use Cake\\Http\\ServerRequest ; use Cake\\View\\Helper\\PaginatorHelper ; $json = ( new JsonSerializer ( $data , new ServerRequest (), new PaginatorHelper ())) -> asJson (); View the JsonSerializer for more details. Unit Tests # unit test only vendor/bin/phpunit # standards checking composer check","title":"MixerApi HAL View"},{"location":"hal-view/#mixerapi-hal-view","text":"Note, this is a beta library A Hypertext Application Language ( HAL+JSON ) View for CakePHP. This plugin supports links, pagination, and embedded resources. Once setup any request with application/hal+json will be rendered by this plugin.","title":"MixerApi HAL View"},{"location":"hal-view/#table-of-contents","text":"Installation Setup Usage Serializing","title":"Table of Contents"},{"location":"hal-view/#installation","text":"composer require mixerapi/hal-view bin/cake plugin load MixerApi/HalView Alternatively after composer installing you can manually load the plugin in your Application: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/HalView' ); }","title":"Installation"},{"location":"hal-view/#setup","text":"Your controllers must be using the RequestHandler component. This is typically loaded in your AppController . # src/Controller/AppController.php public function initialize () : void { parent :: initialize (); $this -> loadComponent ( 'RequestHandler' ); // other logic... }","title":"Setup"},{"location":"hal-view/#usage","text":"For _link.self.href support you will need to implement MixerApi\\HalView\\HalResourceInterface on entities that you want to expose as HAL resources. This informs the plugin that the Entity should be treated as a HAL resource and provides the mapper with a _link.self.href URL. Example: <? php declare ( strict_types = 1 ); namespace App\\Model\\Entity ; use Cake\\ORM\\Entity ; use MixerApi\\HalView\\HalResourceInterface ; use Cake\\Datasource\\EntityInterface ; class Actor extends Entity implements HalResourceInterface { // your various properties and logic /** * @param EntityInterface $entity * @return array|\\string[][] */ public function getHalLinks ( EntityInterface $entity ) : array { return [ 'self' => [ 'href' => '/actors/' . $entity -> get ( 'id' ) ] ]; } } Now an HTTP GET to the /actors/1 endpoint will render HAL using the CakePHP native serialization process: #src/Controller/ActorsController.php public function view ( $id = null ) { $this -> request -> allowMethod ( 'get' ); $actor = $this -> Actors -> get ( $id , [ 'contain' => [ 'Films' ], ]); $this -> set ( 'actor' , $actor ); $this -> viewBuilder () -> setOption ( 'serialize' , 'actor' ); } Output: { \"_links\" : { \"self\" : { \"href\" : \"/actors/149\" } }, \"id\" : 149 , \"first_name\" : \"RUSSELL\" , \"last_name\" : \"TEMPLE\" , \"modified\" : \"2006-02-15T04:34:33+00:00\" , \"_embedded\" : { \"films\" : [ { \"id\" : 53 , \"title\" : \"BANG KWAI\" , \"description\" : \"A Epic Drama of a Madman And a Cat who must Face a A Shark in An Abandoned Amusement Park\" , \"release_year\" : \"2006\" , \"language_id\" : 1 , \"rental_duration\" : 5 , \"rental_rate\" : \"2.99\" , \"length\" : 87 , \"replacement_cost\" : \"25.99\" , \"rating\" : \"NC-17\" , \"special_features\" : \"Commentaries,Deleted Scenes,Behind the Scenes\" , \"modified\" : \"2006-02-15T05:03:42+00:00\" \"_links\" : { \"self\" : { \"href\" : \"/films/53\" } } } ] } } If your Entity does not implement the interface it will still be returned as HAL resource when serialized, but minus the _links property. Collection requests will work without this interface as well, example: #src/Controller/ActorsController.php public function index () { $this -> request -> allowMethod ( 'get' ); $actors = $this -> paginate ( $this -> Actors , [ 'contain' => [ 'Films' ], ]); $this -> set ( compact ( 'actors' )); $this -> viewBuilder () -> setOption ( 'serialize' , 'actors' ); } Output: { \"_links\" : { \"self\" : { \"href\" : \"/actors?page=3\" }, \"next\" : { \"href\" : \"/actors?page=4\" }, \"prev\" : { \"href\" : \"/actors?page=2\" }, \"first\" : { \"href\" : \"/actors?page=1\" }, \"last\" : { \"href\" : \"/actors?page=11\" } }, \"count\" : 20 , \"total\" : 207 , \"_embedded\" : { \"actors\" : [ { \"id\" : 1 , \"first_name\" : \"PENELOPE\" , \"last_name\" : \"GUINESS\" , \"modified\" : \"2006-02-15T04:34:33+00:00\" \"_embedded\" : { \"films\" : [ { \"id\" : 1 , \"title\" : \"ACADEMY DINOSAUR\" , \"description\" : \"A Epic Drama of a Feminist And a Mad Scientist who must Battle a Teacher in The Canadian Rockies\" , \"release_year\" : \"2006\" , \"language_id\" : 1 , \"rental_duration\" : 6 , \"rental_rate\" : \"0.99\" , \"length\" : 86 , \"replacement_cost\" : \"20.99\" , \"rating\" : \"PG\" , \"special_features\" : \"Deleted Scenes,Behind the Scenes\" , \"modified\" : \"2006-02-15T05:03:42+00:00\" } ] } } ] } } If the Actor and Film entities were implementing MixerApi\\HalView\\HalResourceInterface then the example above would include the _links property for each serialized entity. Try it out for yourself: # json curl -X GET \"http://localhost:8765/actors\" -H \"accept: application/hal+json\"","title":"Usage"},{"location":"hal-view/#serializing","text":"Optionally, you can manually serialize data into HAL using JsonSerializer . This is the same class that the main HalJsonView uses. Example: use MixerApi\\HalView\\JsonSerializer ; # json $json = ( new JsonSerializer ( $data )) -> asJson ( JSON_PRETTY_PRINT ); // asJson argument is optional # array $hal = ( new JsonSerializer ( $data )) -> getData (); # json with `_links.self.href` and pagination meta data use Cake\\Http\\ServerRequest ; use Cake\\View\\Helper\\PaginatorHelper ; $json = ( new JsonSerializer ( $data , new ServerRequest (), new PaginatorHelper ())) -> asJson (); View the JsonSerializer for more details.","title":"Serializing"},{"location":"hal-view/#unit-tests","text":"# unit test only vendor/bin/phpunit # standards checking composer check","title":"Unit Tests"},{"location":"json-ld-view/","text":"MixerAPI JsonLdView Note, this is an alpha library A JSON-LD View for CakePHP. Table of Contents Installation Setup Usage Installation composer require mixerapi/json-ld-view bin/cake plugin load MixerApi/JsonLdView Alternatively after composer installing you can manually load the plugin in your Application: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/JsonLdView' ); } Setup Setup for this plugin is very easy. Just load the RequestHandler component and create a route for contexts and vocab. Then create a config/jsonld_config.php config file (recommended) and implement JsonLdDataInterface on your entities. Config (recommended) Create a config/jsonld_config . If you skip this step then the defaults listed in the sample config will be used. RequestHandler Your controllers must be using the RequestHandler component. This is typically loaded in your AppController . In most cases this is already loaded. # src/Controller/AppController.php public function initialize () : void { parent :: initialize (); $this -> loadComponent ( 'RequestHandler' ); // other logic... } Routes The contexts route displays your JSON-LD schema for an entity, while the vocab route will display all entities and additional metadata. # config/routes.php $routes -> scope ( '/' , function ( RouteBuilder $builder ) { $builder -> connect ( '/contexts/*' , [ 'plugin' => 'MixerApi/JsonLdView' , 'controller' => 'JsonLd' , 'action' => 'contexts' ]); $builder -> connect ( '/vocab' , [ 'plugin' => 'MixerApi/JsonLdView' , 'controller' => 'JsonLd' , 'action' => 'vocab' ]); // ... other code }); You should now be able see entities JSON-LD schema by browsing to /contexts/{entity-name} . For further customization you can copy the JsonLdController into your own project. Route Extension (optional) If you would like to request JSON-LD by extension (e.g. /index.jsonld ) you'll need to set the extension in your config/routes.php , example: # config/routes.php $routes -> scope ( '/' , function ( RouteBuilder $builder ) { $builder -> setExtensions ([ 'jsonld' ]); // ... other code }); Usage Once setup is complete request types of application/ld+json will automatically be rendered as JSON-LD. Entity Schema This plugin will map basic types (int, string, decimal etc.) to their corresponding schema.org values. For instance, int is mapped to https://schema.org/Number . You can improve the mappings by defining proper Validations on your Table class. For instance, fields with the email rule will be mapped to https://schema.org/email . For a full list of default mappings refer to the SchemaMapper . You can further customize the schema mapping by implementing MixerApi\\JsonLdView\\JsonLdDataInterface on your applications Entities. See the doc block comments in the example for additional insight: # App/Model/Entity/Film.php class Film extends Entity implements JsonLdDataInterface { // ...other code /** * This is the context URL that you defined in your routes during Setup. This is used to browse the schema * definitions and appears as `@context` when displaying collection or item results * * @return string */ public function getJsonLdContext () : string { return '/context/Film' ; } /** * This is the Entities schema description and appears as `@type` when displaying collection or item results * * @return string */ public function getJsonLdType () : string { return 'https://schema.org/movie' ; } /** * This is the Entities URL and appears as `@id` when displaying collection or item results * * @param EntityInterface $entity * @return string */ public function getJsonLdIdentifier ( EntityInterface $entity ) : string { return '/films/' . $entity -> get ( 'id' ); } /** * You can define custom schemas here. These definitions take precedence and will appear when browsing to the * entities context URL. You can simply return an empty array if you don't care to define a schema. * * @return \\MixerApi\\JsonLdView\\JsonLdSchema[] */ public function getJsonLdSchemas () : array { return [ ( new JsonLdSchema ()) -> setProperty ( 'title' ) -> setSchemaUrl ( 'https://schema.org/name' ) -> setDescription ( 'optional' ), ( new JsonLdSchema ()) -> setProperty ( 'description' ) -> setSchemaUrl ( 'https://schema.org/about' ), ( new JsonLdSchema ()) -> setProperty ( 'length' ) -> setSchemaUrl ( 'https://schema.org/duration' ), ( new JsonLdSchema ()) -> setProperty ( 'rating' ) -> setSchemaUrl ( 'https://schema.org/contentRating' ), ( new JsonLdSchema ()) -> setProperty ( 'release_year' ) -> setSchemaUrl ( 'https://schema.org/copyrightYear' ), ]; } } Collections We get the @id and @context properties because these Entities implement JsonLdDataInterface . This interface is of course optional and data will return without it minus the aforementioned properties. Pagination data is added in the view property per the Hydra PartialCollectionView specification. #src/Controller/FilmsController.php public function index () { $this -> request -> allowMethod ( 'get' ); $actors = $this -> paginate ( $this -> Films , [ 'contain' => [ 'Languages' ], ]); $this -> set ( compact ( 'films' )); $this -> viewBuilder () -> setOption ( 'serialize' , 'films' ); } Output: { \"@context\" : \"/context/Film\" , \"@id\" : \"/films\" , \"@type\" : \"Collection\" , \"pageItems\" : 20 , \"totalItems\" : 1 , \"view\" : { \"@id\" : \"/films\" , \"@type\" : \"PartialCollectionView\" , \"next\" : \"/films?page=2\" , \"prev\" : \"\" , \"first\" : \"\" , \"last\" : \"/films?page=50\" }, \"member\" : [ { \"id\" : 1 , \"title\" : \"ACADEMY DINOSAUR\" , \"description\" : \"A Epic Drama of a Feminist And a Mad Scientist who must Battle a Teacher in The Canadian Rockies\" , \"modified\" : \"2006-02-15T05:03:42+00:00\" , \"language\" : { \"id\" : 1 , \"name\" : \"English\" , \"@id\" : \"/languages/1\" , \"@type\" : \"https://schema.org/Language\" , \"@context\" : \"/context/Language\" }, \"@id\" : \"/films/1\" , \"@type\" : \"https://schema.org/Movie\" , \"@context\" : \"/context/Film\" } ] } Items #src/Controller/LanguagesController.php public function view ( $id = null ) { $this -> request -> allowMethod ( 'get' ); $languages = $this -> Languages -> get ( $id ); $this -> set ( 'languages' , $languages ); $this -> viewBuilder () -> setOption ( 'serialize' , 'languages' ); } Output: { \"@id\" : \"/languages/1\" , \"@type\" : \"https://schema.org/Language\" , \"@context\" : \"/context/Language\" , \"id\" : 1 , \"name\" : \"English\" } Contexts Browsing to the contexts route will display information about that entity. To fine tune to the data you will need to implement JsonLdDataInterface. Using the Film entity as an example, the context looks like this when browsing to /contexts/Film : { \"@context\" : { \"@vocab\" : \"/vocab\" , \"hydra\" : \"http://www.w3.org/ns/hydra/core#\" , \"title\" : \"https://schema.org/name\" , \"description\" : \"https://schema.org/about\" , \"length\" : \"https://schema.org/duration\" , \"rating\" : \"https://schema.org/contentRating\" , \"release_year\" : \"https://schema.org/copyrightYear\" , \"id\" : \"https://schema.org/identifier\" , \"language_id\" : \"https://schema.org/Number\" , \"rental_duration\" : \"https://schema.org/Number\" , \"rental_rate\" : \"https://schema.org/Float\" , \"replacement_cost\" : \"https://schema.org/Float\" , \"special_features\" : \"https://schema.org/Text\" , \"modified\" : \"https://schema.org/DateTime\" } } Vocab Any entities implementing the JsonLdDataInterface will appear when browsing to the route you created for vocab (e.g. /vocab): Sample: { \"@contexts\" : { \"@vocab\" : \"/vocab\" , \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" , \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\" , \"xmls\" : \"http://www.w3.org/2001/XMLSchema#\" , \"owl\" : \"http://www.w3.org/2002/07/owl#\" , \"schema\" : \"http://schema.org\" }, \"@id\" : \"/vocab\" , \"@type\" : \"ApiDocumentation\" , \"title\" : \"API Documentation\" , \"description\" : \"\" , \"supportedClass\" : [ { \"@id\" : \"https://schema.org/Language\" , \"@type\" : \"Class\" , \"title\" : \"Language\" , \"supportedProperty\" : [ { \"@type\" : \"supportedProperty\" , \"property\" : { \"@id\" : \"https://schema.org/name\" , \"@type\" : \"rdf:Property\" , \"rdfs:label\" : \"name\" , \"domain\" : \"https://schema.org/Language\" , \"range\" : \"xmls:char\" }, \"title\" : \"name\" , \"required\" : false , \"readable\" : true , \"writeable\" : true , \"description\" : \"\" } ] } // ...and other items ] } Serializing Optionally, you can manually serialize data into JSON-LD using JsonSerializer . Example: use MixerApi\\JsonLdView\\JsonSerializer ; # json $json = ( new JsonSerializer ( $data )) -> asJson ( JSON_PRETTY_PRINT ); // argument is optional # array $hal = ( new JsonSerializer ( $data )) -> getData (); # json-ld with pagination meta data use Cake\\Http\\ServerRequest ; use Cake\\View\\Helper\\PaginatorHelper ; $json = ( new JsonSerializer ( $data , new ServerRequest (), new PaginatorHelper ())) -> asJson (); Unit Tests vendor/bin/phpunit Code Standards composer check","title":"MixerAPI JsonLdView"},{"location":"json-ld-view/#mixerapi-jsonldview","text":"Note, this is an alpha library A JSON-LD View for CakePHP.","title":"MixerAPI JsonLdView"},{"location":"json-ld-view/#table-of-contents","text":"Installation Setup Usage","title":"Table of Contents"},{"location":"json-ld-view/#installation","text":"composer require mixerapi/json-ld-view bin/cake plugin load MixerApi/JsonLdView Alternatively after composer installing you can manually load the plugin in your Application: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/JsonLdView' ); }","title":"Installation"},{"location":"json-ld-view/#setup","text":"Setup for this plugin is very easy. Just load the RequestHandler component and create a route for contexts and vocab. Then create a config/jsonld_config.php config file (recommended) and implement JsonLdDataInterface on your entities.","title":"Setup"},{"location":"json-ld-view/#config-recommended","text":"Create a config/jsonld_config . If you skip this step then the defaults listed in the sample config will be used.","title":"Config (recommended)"},{"location":"json-ld-view/#requesthandler","text":"Your controllers must be using the RequestHandler component. This is typically loaded in your AppController . In most cases this is already loaded. # src/Controller/AppController.php public function initialize () : void { parent :: initialize (); $this -> loadComponent ( 'RequestHandler' ); // other logic... }","title":"RequestHandler"},{"location":"json-ld-view/#routes","text":"The contexts route displays your JSON-LD schema for an entity, while the vocab route will display all entities and additional metadata. # config/routes.php $routes -> scope ( '/' , function ( RouteBuilder $builder ) { $builder -> connect ( '/contexts/*' , [ 'plugin' => 'MixerApi/JsonLdView' , 'controller' => 'JsonLd' , 'action' => 'contexts' ]); $builder -> connect ( '/vocab' , [ 'plugin' => 'MixerApi/JsonLdView' , 'controller' => 'JsonLd' , 'action' => 'vocab' ]); // ... other code }); You should now be able see entities JSON-LD schema by browsing to /contexts/{entity-name} . For further customization you can copy the JsonLdController into your own project.","title":"Routes"},{"location":"json-ld-view/#route-extension-optional","text":"If you would like to request JSON-LD by extension (e.g. /index.jsonld ) you'll need to set the extension in your config/routes.php , example: # config/routes.php $routes -> scope ( '/' , function ( RouteBuilder $builder ) { $builder -> setExtensions ([ 'jsonld' ]); // ... other code });","title":"Route Extension (optional)"},{"location":"json-ld-view/#usage","text":"Once setup is complete request types of application/ld+json will automatically be rendered as JSON-LD.","title":"Usage"},{"location":"json-ld-view/#entity-schema","text":"This plugin will map basic types (int, string, decimal etc.) to their corresponding schema.org values. For instance, int is mapped to https://schema.org/Number . You can improve the mappings by defining proper Validations on your Table class. For instance, fields with the email rule will be mapped to https://schema.org/email . For a full list of default mappings refer to the SchemaMapper . You can further customize the schema mapping by implementing MixerApi\\JsonLdView\\JsonLdDataInterface on your applications Entities. See the doc block comments in the example for additional insight: # App/Model/Entity/Film.php class Film extends Entity implements JsonLdDataInterface { // ...other code /** * This is the context URL that you defined in your routes during Setup. This is used to browse the schema * definitions and appears as `@context` when displaying collection or item results * * @return string */ public function getJsonLdContext () : string { return '/context/Film' ; } /** * This is the Entities schema description and appears as `@type` when displaying collection or item results * * @return string */ public function getJsonLdType () : string { return 'https://schema.org/movie' ; } /** * This is the Entities URL and appears as `@id` when displaying collection or item results * * @param EntityInterface $entity * @return string */ public function getJsonLdIdentifier ( EntityInterface $entity ) : string { return '/films/' . $entity -> get ( 'id' ); } /** * You can define custom schemas here. These definitions take precedence and will appear when browsing to the * entities context URL. You can simply return an empty array if you don't care to define a schema. * * @return \\MixerApi\\JsonLdView\\JsonLdSchema[] */ public function getJsonLdSchemas () : array { return [ ( new JsonLdSchema ()) -> setProperty ( 'title' ) -> setSchemaUrl ( 'https://schema.org/name' ) -> setDescription ( 'optional' ), ( new JsonLdSchema ()) -> setProperty ( 'description' ) -> setSchemaUrl ( 'https://schema.org/about' ), ( new JsonLdSchema ()) -> setProperty ( 'length' ) -> setSchemaUrl ( 'https://schema.org/duration' ), ( new JsonLdSchema ()) -> setProperty ( 'rating' ) -> setSchemaUrl ( 'https://schema.org/contentRating' ), ( new JsonLdSchema ()) -> setProperty ( 'release_year' ) -> setSchemaUrl ( 'https://schema.org/copyrightYear' ), ]; } }","title":"Entity Schema"},{"location":"json-ld-view/#collections","text":"We get the @id and @context properties because these Entities implement JsonLdDataInterface . This interface is of course optional and data will return without it minus the aforementioned properties. Pagination data is added in the view property per the Hydra PartialCollectionView specification. #src/Controller/FilmsController.php public function index () { $this -> request -> allowMethod ( 'get' ); $actors = $this -> paginate ( $this -> Films , [ 'contain' => [ 'Languages' ], ]); $this -> set ( compact ( 'films' )); $this -> viewBuilder () -> setOption ( 'serialize' , 'films' ); } Output: { \"@context\" : \"/context/Film\" , \"@id\" : \"/films\" , \"@type\" : \"Collection\" , \"pageItems\" : 20 , \"totalItems\" : 1 , \"view\" : { \"@id\" : \"/films\" , \"@type\" : \"PartialCollectionView\" , \"next\" : \"/films?page=2\" , \"prev\" : \"\" , \"first\" : \"\" , \"last\" : \"/films?page=50\" }, \"member\" : [ { \"id\" : 1 , \"title\" : \"ACADEMY DINOSAUR\" , \"description\" : \"A Epic Drama of a Feminist And a Mad Scientist who must Battle a Teacher in The Canadian Rockies\" , \"modified\" : \"2006-02-15T05:03:42+00:00\" , \"language\" : { \"id\" : 1 , \"name\" : \"English\" , \"@id\" : \"/languages/1\" , \"@type\" : \"https://schema.org/Language\" , \"@context\" : \"/context/Language\" }, \"@id\" : \"/films/1\" , \"@type\" : \"https://schema.org/Movie\" , \"@context\" : \"/context/Film\" } ] }","title":"Collections"},{"location":"json-ld-view/#items","text":"#src/Controller/LanguagesController.php public function view ( $id = null ) { $this -> request -> allowMethod ( 'get' ); $languages = $this -> Languages -> get ( $id ); $this -> set ( 'languages' , $languages ); $this -> viewBuilder () -> setOption ( 'serialize' , 'languages' ); } Output: { \"@id\" : \"/languages/1\" , \"@type\" : \"https://schema.org/Language\" , \"@context\" : \"/context/Language\" , \"id\" : 1 , \"name\" : \"English\" }","title":"Items"},{"location":"json-ld-view/#contexts","text":"Browsing to the contexts route will display information about that entity. To fine tune to the data you will need to implement JsonLdDataInterface. Using the Film entity as an example, the context looks like this when browsing to /contexts/Film : { \"@context\" : { \"@vocab\" : \"/vocab\" , \"hydra\" : \"http://www.w3.org/ns/hydra/core#\" , \"title\" : \"https://schema.org/name\" , \"description\" : \"https://schema.org/about\" , \"length\" : \"https://schema.org/duration\" , \"rating\" : \"https://schema.org/contentRating\" , \"release_year\" : \"https://schema.org/copyrightYear\" , \"id\" : \"https://schema.org/identifier\" , \"language_id\" : \"https://schema.org/Number\" , \"rental_duration\" : \"https://schema.org/Number\" , \"rental_rate\" : \"https://schema.org/Float\" , \"replacement_cost\" : \"https://schema.org/Float\" , \"special_features\" : \"https://schema.org/Text\" , \"modified\" : \"https://schema.org/DateTime\" } }","title":"Contexts"},{"location":"json-ld-view/#vocab","text":"Any entities implementing the JsonLdDataInterface will appear when browsing to the route you created for vocab (e.g. /vocab): Sample: { \"@contexts\" : { \"@vocab\" : \"/vocab\" , \"rdf\" : \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\" , \"rdfs\" : \"http://www.w3.org/2000/01/rdf-schema#\" , \"xmls\" : \"http://www.w3.org/2001/XMLSchema#\" , \"owl\" : \"http://www.w3.org/2002/07/owl#\" , \"schema\" : \"http://schema.org\" }, \"@id\" : \"/vocab\" , \"@type\" : \"ApiDocumentation\" , \"title\" : \"API Documentation\" , \"description\" : \"\" , \"supportedClass\" : [ { \"@id\" : \"https://schema.org/Language\" , \"@type\" : \"Class\" , \"title\" : \"Language\" , \"supportedProperty\" : [ { \"@type\" : \"supportedProperty\" , \"property\" : { \"@id\" : \"https://schema.org/name\" , \"@type\" : \"rdf:Property\" , \"rdfs:label\" : \"name\" , \"domain\" : \"https://schema.org/Language\" , \"range\" : \"xmls:char\" }, \"title\" : \"name\" , \"required\" : false , \"readable\" : true , \"writeable\" : true , \"description\" : \"\" } ] } // ...and other items ] }","title":"Vocab"},{"location":"json-ld-view/#serializing","text":"Optionally, you can manually serialize data into JSON-LD using JsonSerializer . Example: use MixerApi\\JsonLdView\\JsonSerializer ; # json $json = ( new JsonSerializer ( $data )) -> asJson ( JSON_PRETTY_PRINT ); // argument is optional # array $hal = ( new JsonSerializer ( $data )) -> getData (); # json-ld with pagination meta data use Cake\\Http\\ServerRequest ; use Cake\\View\\Helper\\PaginatorHelper ; $json = ( new JsonSerializer ( $data , new ServerRequest (), new PaginatorHelper ())) -> asJson ();","title":"Serializing"},{"location":"json-ld-view/#unit-tests","text":"vendor/bin/phpunit","title":"Unit Tests"},{"location":"json-ld-view/#code-standards","text":"composer check","title":"Code Standards"},{"location":"mixerapi/","text":"MixerAPI Streamline development of API-first applications in CakePHP Note: This is an alpha stage plugin MixerAPI is a plugin of plugins, that is to say, it combines many CakePHP libraries into a coherent package to streamline API development for CakePHP applications. It eases following a REST architecture style and HATEOS . In other words, it makes developing APIs a piece of cake. Demo Application | Demo Source Code Installation composer require mixerapi/mixerapi Setup To load all MixerApi plugins run bin/cake plugin load MixerApi . Alternatively, you can modify your Applications bootstrap method yourself: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi' ); } You can also load plugins individually. For instance, if your project only requires HalView and SwaggerBake your Application->bootstrap() would resemble this: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/HalView' ); $this -> addPlugin ( 'SwaggerBake' ); } If you don't need the entire suite of plugins simply composer require on an as-needed basis. It's up to you! MixerAPI Core Plugins MixerAPI automatically installs the following plugins for your RESTful API project: MixerApi/Bake A custom bake template focused on creating RESTful CakePHP controllers in seconds. # bake all your controllers bin/cake bake controller all --theme MixerApi/Bake Read the full documentation here . MixerApi/Rest Gets your API project up and going quickly by creating routes for you. It can either: Build your routes.php file from a single command, or Automatically expose RESTful CRUD routes with a handy AutoRouter class. # config/routes.php $routes->scope('/', function (RouteBuilder $builder) { // ... other routes (new AutoRouter($builder))->buildResources(); // ... other routes }); Read the full documentation here . SwaggerBake A delightfully tasty tool for generating Swagger documentation with OpenApi 3.0.0 schema. This plugin automatically builds your Swagger UI and ReDoc from your existing cake models and routes. Read the full documentation here . MixerApi/HalView A Hypertext Application Language ( HAL+JSON ) View for CakePHP. This plugin supports links, pagination, and embedded resources. Once setup any request with application/hal+json will be rendered by this plugin. Read the full documentation here . MixerApi/JsonLdView A JSON-LD View for CakePHP. Read the full documentation here . MixerApi/CollectionView A Collection View for displaying configurable pagination meta-data in JSON or XML collection responses. Read the full documentation here . MixerApi/ExceptionRender Handles rendering entity validation errors and other exceptions for your API. # config/app.php 'Error' => [ 'errorLevel' => E_ALL , 'exceptionRenderer' => MixerApi\\ExceptionRender\\MixerApiExceptionRenderer :: class , 'skipLog' => [], 'log' => true , 'trace' => true , ], Read the full documentation here . CakePHP Community Plugins Search Search provides a simple interface to create paginate-able filters for your CakePHP application. Search helps you easily expose searching your resources through HTTP GET query parameters and integrates fully with SwaggerBake. Read the full documentation here . For integrating with SwaggerBake checkout this link . Unit Tests vendor/bin/phpunit Code Standards composer check ```","title":"Index"},{"location":"mixerapi/#installation","text":"composer require mixerapi/mixerapi","title":"Installation"},{"location":"mixerapi/#setup","text":"To load all MixerApi plugins run bin/cake plugin load MixerApi . Alternatively, you can modify your Applications bootstrap method yourself: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi' ); } You can also load plugins individually. For instance, if your project only requires HalView and SwaggerBake your Application->bootstrap() would resemble this: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/HalView' ); $this -> addPlugin ( 'SwaggerBake' ); } If you don't need the entire suite of plugins simply composer require on an as-needed basis. It's up to you!","title":"Setup"},{"location":"mixerapi/#mixerapi-core-plugins","text":"MixerAPI automatically installs the following plugins for your RESTful API project:","title":"MixerAPI Core Plugins"},{"location":"mixerapi/#mixerapibake","text":"A custom bake template focused on creating RESTful CakePHP controllers in seconds. # bake all your controllers bin/cake bake controller all --theme MixerApi/Bake Read the full documentation here .","title":"MixerApi/Bake"},{"location":"mixerapi/#mixerapirest","text":"Gets your API project up and going quickly by creating routes for you. It can either: Build your routes.php file from a single command, or Automatically expose RESTful CRUD routes with a handy AutoRouter class. # config/routes.php $routes->scope('/', function (RouteBuilder $builder) { // ... other routes (new AutoRouter($builder))->buildResources(); // ... other routes }); Read the full documentation here .","title":"MixerApi/Rest"},{"location":"mixerapi/#swaggerbake","text":"A delightfully tasty tool for generating Swagger documentation with OpenApi 3.0.0 schema. This plugin automatically builds your Swagger UI and ReDoc from your existing cake models and routes. Read the full documentation here .","title":"SwaggerBake"},{"location":"mixerapi/#mixerapihalview","text":"A Hypertext Application Language ( HAL+JSON ) View for CakePHP. This plugin supports links, pagination, and embedded resources. Once setup any request with application/hal+json will be rendered by this plugin. Read the full documentation here .","title":"MixerApi/HalView"},{"location":"mixerapi/#mixerapijsonldview","text":"A JSON-LD View for CakePHP. Read the full documentation here .","title":"MixerApi/JsonLdView"},{"location":"mixerapi/#mixerapicollectionview","text":"A Collection View for displaying configurable pagination meta-data in JSON or XML collection responses. Read the full documentation here .","title":"MixerApi/CollectionView"},{"location":"mixerapi/#mixerapiexceptionrender","text":"Handles rendering entity validation errors and other exceptions for your API. # config/app.php 'Error' => [ 'errorLevel' => E_ALL , 'exceptionRenderer' => MixerApi\\ExceptionRender\\MixerApiExceptionRenderer :: class , 'skipLog' => [], 'log' => true , 'trace' => true , ], Read the full documentation here .","title":"MixerApi/ExceptionRender"},{"location":"mixerapi/#cakephp-community-plugins","text":"","title":"CakePHP Community Plugins"},{"location":"mixerapi/#search","text":"Search provides a simple interface to create paginate-able filters for your CakePHP application. Search helps you easily expose searching your resources through HTTP GET query parameters and integrates fully with SwaggerBake. Read the full documentation here . For integrating with SwaggerBake checkout this link .","title":"Search"},{"location":"mixerapi/#unit-tests","text":"vendor/bin/phpunit","title":"Unit Tests"},{"location":"mixerapi/#code-standards","text":"composer check ```","title":"Code Standards"},{"location":"rest/","text":"MixerApi REST Note: This is an alpha stage plugin This plugin gets your API project up and going quickly by creating routes for you. It can either: Build your routes.php file from a single command, or Automatically expose RESTful CRUD routes with a handy AutoRouter. This plugin assumes you have already created models and controllers. For help with the latter check out MixerApi/Bake . Check the official RESTful routing documentation for handling advanced routing scenarios not covered by this plugin. Table of Contents Installation AutoRouter Create Routes Installation composer require mixerapi/rest bin/cake plugin load MixerApi/Rest Alternatively after composer installing you can manually load the plugin in your Application: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/Rest' ); } AutoRouter Creating routes is already pretty easy, but AutoRouter makes building CRUD routes effortless. This is great if you are just getting started with building APIs in CakePHP. In your routes.php simply add \\MixerApi\\Rest\\Lib\\AutoRouter : # config/routes.php $routes -> scope ( '/' , function ( RouteBuilder $builder ) { // ... other routes ( new AutoRouter ( $builder )) -> buildResources (); // ... other routes }); This will add routes for CRUD controller actions (index, add, edit, view, and delete). If your controller does not have any CRUD methods, then the route will be skipped. AutoRouting works for plugins too: # in your plugins/{PluginName}/routes.php file ( new AutoRouter ( $builder , 'MyPlugin\\Controller' )) -> buildResources (); Create Routes While AutoRouter makes life easy, it must scan your controllers to build RESTful resources. This has a slight performance penalty. No worry, you can use mixerapi:rest route create to code your routes for you. This will write routes directly to your routes.php file. # writes to `config/routes.php` bin/cake mixerapi:rest route create Use --prefix to specify a prefix: bin/cake mixerapi:rest route create --prefix /api Use --plugin for plugins: # writes to `plugins/MyPlugin/config/routes.php` bin/cake mixerapi:rest route create --plugin MyPlugin To perform a dry-run use the --display option: bin/cake mixerapi:rest route create --display For non-CRUD routes, sub-resources, and advanced routing please reference the CakePHP RESTful routing documentation List Routes This works similar to bin/cake routes but shows only RESTful routes and improves some formatting of information. bin/cake mixerapi:rest route list To limit output to a specific plugin use the --plugin option: # limit to a plugin: bin/cake mixerapi:rest route list --plugin MyPlugin #limit to main application: bin/cake mixerapi:rest route list --plugin App Unit Tests vendor/bin/phpunit Code Standards composer check","title":"MixerApi REST"},{"location":"rest/#mixerapi-rest","text":"Note: This is an alpha stage plugin This plugin gets your API project up and going quickly by creating routes for you. It can either: Build your routes.php file from a single command, or Automatically expose RESTful CRUD routes with a handy AutoRouter. This plugin assumes you have already created models and controllers. For help with the latter check out MixerApi/Bake . Check the official RESTful routing documentation for handling advanced routing scenarios not covered by this plugin.","title":"MixerApi REST"},{"location":"rest/#table-of-contents","text":"Installation AutoRouter Create Routes","title":"Table of Contents"},{"location":"rest/#installation","text":"composer require mixerapi/rest bin/cake plugin load MixerApi/Rest Alternatively after composer installing you can manually load the plugin in your Application: # src/Application.php public function bootstrap () : void { // other logic... $this -> addPlugin ( 'MixerApi/Rest' ); }","title":"Installation"},{"location":"rest/#autorouter","text":"Creating routes is already pretty easy, but AutoRouter makes building CRUD routes effortless. This is great if you are just getting started with building APIs in CakePHP. In your routes.php simply add \\MixerApi\\Rest\\Lib\\AutoRouter : # config/routes.php $routes -> scope ( '/' , function ( RouteBuilder $builder ) { // ... other routes ( new AutoRouter ( $builder )) -> buildResources (); // ... other routes }); This will add routes for CRUD controller actions (index, add, edit, view, and delete). If your controller does not have any CRUD methods, then the route will be skipped. AutoRouting works for plugins too: # in your plugins/{PluginName}/routes.php file ( new AutoRouter ( $builder , 'MyPlugin\\Controller' )) -> buildResources ();","title":"AutoRouter"},{"location":"rest/#create-routes","text":"While AutoRouter makes life easy, it must scan your controllers to build RESTful resources. This has a slight performance penalty. No worry, you can use mixerapi:rest route create to code your routes for you. This will write routes directly to your routes.php file. # writes to `config/routes.php` bin/cake mixerapi:rest route create Use --prefix to specify a prefix: bin/cake mixerapi:rest route create --prefix /api Use --plugin for plugins: # writes to `plugins/MyPlugin/config/routes.php` bin/cake mixerapi:rest route create --plugin MyPlugin To perform a dry-run use the --display option: bin/cake mixerapi:rest route create --display For non-CRUD routes, sub-resources, and advanced routing please reference the CakePHP RESTful routing documentation","title":"Create Routes"},{"location":"rest/#list-routes","text":"This works similar to bin/cake routes but shows only RESTful routes and improves some formatting of information. bin/cake mixerapi:rest route list To limit output to a specific plugin use the --plugin option: # limit to a plugin: bin/cake mixerapi:rest route list --plugin MyPlugin #limit to main application: bin/cake mixerapi:rest route list --plugin App","title":"List Routes"},{"location":"rest/#unit-tests","text":"vendor/bin/phpunit","title":"Unit Tests"},{"location":"rest/#code-standards","text":"composer check","title":"Code Standards"}]}